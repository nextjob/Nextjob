SUBROUTINE CREDIT.DIALOG(GUIERRORS,GUISTATE)
!
**************************************************************************
* This is free and unencumbered software released into the public domain.
*
* Anyone is free to copy, modify, publish, use, compile, sell, or
* distribute this software, either in source code form or as a compiled
* binary, for any purpose, commercial or non-commercial, and by any
* means.
*
* In jurisdictions that recognize copyright laws, the author or authors
* of this software dedicate any and all copyright interest in the
* software to the public domain. We make this dedication for the benefit
* of the public at large and to the detriment of our heirs and
* successors. We intend this dedication to be an overt act of
* relinquishment in perpetuity of all present and future rights to this
* software under copyright law.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
* IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
* OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
* OTHER DEALINGS IN THE SOFTWARE.
*
* For more information, please refer to <https://unlicense.org>
**************************************************************************
*
* MODULE: CREDIT.DIALOG
* AUTHOR: MAB
* VERSION: 1.0.0
* CREATED: 05/15/2014
* UPDATED:
*
* MAINTENANCE RECORD:
*
* EQUATE:
*
*
* VARIABLES:
*
* FILES:
*
*
* DESIGN DESCRIPTION:
* DIALOG IS CALLED TO MAINTAIN CUSTOMER CREDIT MEMOS
* USER ENTERS SALES ORDER NUMBER FOR WHICH CREDIT IS TO BE ISSUED
* ROUTINE DISPLAYS INVOICED SALES RECORDS FOR SALES ORDER
* USER SELECTS INDIVIDUAL ITEMS TO ISSUE CREDIT FOR (AND ADJUSTS QTY  (AND TOTAL?) AS NECESSARY)
* USER ENTERS DESCRIPTION FOR CREDIT
* USER FILES CREDIT
* ROUTING PROCESSES CREDIT IN THE SAME FASHION AS INV.DIALOG, CREATING A SALES RECORD FOR EACH LINE ITEM SELECTED
* ROUTING CREATES AR RECORD LINKING SALES ORDERS
* ROUTING WRITES GLT RECORDS
*
*
!
** INCLUDE STANDARD VARIABLE, EQUATES
*
*
$INCLUDE NXT.INCLUDES NXT.COMMON
$INCLUDE NXT.INCLUDES NXT.EQUATES
$INCLUDE NXT.INCLUDES NXT.ERR.MSGS
$INCLUDE NXT.INCLUDES SYSTEM_FILE.EQU
$INCLUDE NXT.INCLUDES CUSTOMERS.H
$INCLUDE NXT.INCLUDES ORDER_PARENT.H
$INCLUDE NXT.INCLUDES ORDER_CHILD.H
$INCLUDE NXT.INCLUDES PARTS.H
$INCLUDE NXT.INCLUDES SALES.H
$INCLUDE NXT.INCLUDES VALIDATION_FILE.H
$INCLUDE NXT.INCLUDES AR.H
*
*
$INCLUDE GUIBP ATGUIEQUATES
GUIERRORS = ''
PROG_ID   = "CREDIT.DIALOG"
GUIERRORS = ''
GUIAPP = "CREDIT"  ;* SEED GUIAPP AND GUIFRM PRIOR TO ACTUAL EVENT WAIT LOOP
GUIFRM = "CREDIT"  ;* crease dialog startup time.
*

GUIERRORS = ''
* Open the GUI project file
OPEN 'NXT.FORMS' TO GUI.PROJECT.FILE ELSE
   CALL ATGUIERROR(3,'CREDIT.DIALOG','',0,GRFATAL,"'NXT.FORMS' is not a file name.",GUIERRORS)
   RETURN
END
* Read the GUI template into TEMPLATE
READ TEMPLATE FROM GUI.PROJECT.FILE,'CREDIT.DIALOG' ELSE
   CALL ATGUIERROR(3,'CREDIT.DIALOG','',0,GRFATAL,"'CREDIT.DIALOG' is not on file.",GUIERRORS)
   RETURN
END
* Add your equates and code to open files here...
*
*
************************************************************
*
*
*-->BEGIN GUI HEADER<--*
* If GUISTATE is not NULL, assume GUI has been initialized
IF GUISTATE EQ '' THEN
   CALL ATGUIINIT2(TEMPLATE<2,2>,'',GUIERRORS,GUISTATE)
   IF GUIERRORS<1> >= 3 THEN RETURN
END
* Load the dialog project template
CALL ATGUIRUNMACRO(TEMPLATE,'',GUIERRORS,GUISTATE)
IF GUIERRORS<1> >= 3 THEN RETURN
*-->END GUI HEADER<--*
*
*
************************************************************
*
*
*-->BEGIN GUI STARTUP<--*
ACCEPT = 0 ;* Assume dialog cancelled (update in your OK button Click handler)
* Add your code to load initial values here...
CALL ATGUISHOW('CREDIT','CREDIT','','',GUIERRORS,GUISTATE)
IF GUIERRORS<1> >= 2 THEN RETURN
*-->END GUI STARTUP<--*
*
CALL CREDIT.TEMPLATE(CREDITFORM)  ;* GET CREDIT FORM TEMPLATE
GET_REC_MSG_LIST = ''   ;* DEFAULT MESSAGE LIST
*
* SYSTEM DEFAULTS RECORD
*
CALL GET.RECORD("SYSTEM_FILE",C.SYSTEM_FILE,"DEFAULTS",DEFAULTS_REC,@FALSE,ERROR_STATUS,GET_REC_MSG_LIST,GUIERRORS,GUISTATE)
*
* USER RECORD
*
USER_RECORD_ID = "USER*":@LOGNAME
CALL GET.RECORD("SYSTEM_FILE",C.SYSTEM_FILE,USER_RECORD_ID,USER_REC,@FALSE,ERROR_STATUS,GET_REC_MSG_LIST,GUIERRORS,GUISTATE)
IF USER_REC # '' THEN
   IF USER_REC<USER_PRICE_RESTRICTED> THEN
      USER.IS.RESTRICTED = @TRUE
      LOG.OPTS  = "DISPLAY"
      ERROR_NBR = ERR_SYS
      ERROR_MSG =  "Restricted user: ":@LOGNAME:" does not have access to Invoicing"
      CALL LOG.ERROR(LOG.OPTS,PROG_ID, ERROR_NBR, ERROR_MSG, GUIERRORS, GUISTATE)
      GOSUB GUI.CREDIT.CREDIT.CLOSE;GUIEVT=0
      RETURN
   END ELSE
      USER.IS.RESTRICTED = @FALSE
   END
   *
   * SETUP PRINTERS
   *
   *
   IF USER_REC<USER_INVOICE_PRINTER> = '' THEN
      INVOICE.PRINTER = 0  ;* SET TO DEFAULT PRINTER
      LOG.OPTS  = "DISPLAY"
      ERROR_NBR = ERR_SYS
      ERROR_MSG =  "Missing INVOICE_PRINTER from USER record in, SYSTEM_FILE"
      CALL LOG.ERROR(LOG.OPTS,PROG_ID, ERROR_NBR, ERROR_MSG, GUIERRORS, GUISTATE)
   END ELSE
      INVOICE.PRINTER = USER_REC<USER_INVOICE_PRINTER>
   END
   *
END ELSE
   LOG.OPTS  = "DISPLAY"
   ERROR_NBR = ERR_SYS
   ERROR_MSG =  "Unknown User: ":@LOGNAME
   CALL LOG.ERROR(LOG.OPTS,PROG_ID, ERROR_NBR, ERROR_MSG, GUIERRORS, GUISTATE)
   GOSUB GUI.CREDIT.CREDIT.CLOSE;GUIEVT=0
   RETURN
END
*
* COMPANY RECORD
*
GET_REC_MSG_LIST = ''
CALL GET.RECORD("SYSTEM_FILE",C.SYSTEM_FILE,"COMPANY_RECORD",COMPANY_REC,@FALSE,ERROR_STATUS,GET_REC_MSG_LIST,GUIERRORS,GUISTATE)
IF COMPANY_REC = '' THEN
   LOG.OPTS  = "DISPLAY"
   ERROR_NBR = ERR_SYS
   ERROR_MSG =  "Missing COMPANY_RECORD from SYSTEM_FILE"
   CALL LOG.ERROR(LOG.OPTS,PROG_ID, ERROR_NBR, ERROR_MSG, GUIERRORS, GUISTATE)
   GOSUB GUI.CREDIT.CREDIT.CLOSE;GUIEVT=0
   RETURN
END
*
* GET TERMS
*
CALL GET.RECORD("VALIDTAION_FILE",C.VALIDATION_FILE,"TERMS",TERMS.REC,@FALSE,ERROR_STATUS,GET_REC_MSG_LIST,GUIERRORS,GUISTATE)
IF TERMS.REC = '' THEN
   LOG.OPTS  = "DISPLAY"
   ERROR_NBR = ERR_SYS
   ERROR_MSG =  "TERMS not found in VALIDATION_FILE"
   CALL LOG.ERROR(LOG.OPTS,PROG_ID, ERROR_NBR, ERROR_MSG, GUIERRORS, GUISTATE)
   GOSUB GUI.CREDIT.CREDIT.CLOSE;GUIEVT=0
   RETURN
END
*
GOSUB CLEAR.BUFFERS  ;* INIT VARIABLES USED IN PROG
*
************************************************************
*
*
*-->BEGIN EVENT LOOP<--*
GUI.DLG.EXIT = 0
LOOP
   CALL ATGUIWAITEVENT(GUIAPP,GUIFRM,GUICTL,GUIEVT,GUIARGS,GUIERRORS,GUISTATE)
   IF GUIERRORS<1> >= 2 THEN RETURN
   IF GUIEVT EQ GEQUIT THEN
      GUI.DLG.EXIT = 1
   END ELSE
      GUIAPP=OCONV(GUIAPP,'MCU')
      GUIFRM=OCONV(GUIFRM,'MCU')
      GUICTL=OCONV(GUICTL,'MCU')
      GOSUB GUI.DECODE.EVENT
   END
UNTIL GUI.DLG.EXIT DO REPEAT
* Eat final Quit event
IF GUIEVT <> GEQUIT THEN
   GUI.APP.LIST = ''
   CALL ATGUIGETPROP('','','',GPSTATUS,2,0,GUI.APP.LIST,'',GUISTATE)
   IF GUI.APP.LIST EQ '' THEN
      * Quit event fired after last GUI object is deleted - discard it
      CALL ATGUIWAITEVENT('','','','','','',GUISTATE)
      * We could call ATGUISHUTDOWN here if we wanted, but there's no
      * harm just leaving the GUI environment initialized, in case we
      * want to use it again...
   END
END
*-->END EVENT LOOP<--*
*
*
************************************************************
*
*
*-->BEGIN GUI TRAILER<--*
RETURN
*
GUI.DIALOG.RETURN: *
* This subroutine is called just before the GUI Dialog app
* is deleted. Check the state of the ACCEPT variable, and
* retrieve values from GUI controls and assign to appropriate
* arguments for return to calling program here...
IF ACCEPT THEN
   * Add your code here...
END ELSE
   * Add your code here...
END
RETURN
*-->END GUI TRAILER<--*
*
*
************************************************************
*
*
*-->BEGIN EVENT DECODER<--*
GUI.DECODE.EVENT: *
IF NUM(GUIEVT) THEN
   BEGIN CASE
      CASE GUIAPP='CREDIT'
         BEGIN CASE
            CASE GUIFRM='CREDIT'
               BEGIN CASE
                  CASE GUICTL=''
                     BEGIN CASE
                        CASE GUIEVT=GECLOSE
                           GOSUB GUI.CREDIT.CREDIT.CLOSE;GUIEVT=0
                     END CASE
                  CASE GUICTL='BTNCANCEL'
                     BEGIN CASE
                        CASE GUIEVT=GECLICK
                           GOSUB GUI.CREDIT.CREDIT.BTNCANCEL.CLICK;GUIEVT=0
                     END CASE
                  CASE GUICTL='BTNFILE'
                     BEGIN CASE
                        CASE GUIEVT=GECLICK
                           GOSUB GUI.CREDIT.CREDIT.BTNFILE.CLICK;GUIEVT=0
                     END CASE
                  CASE GUICTL='GRDLINES'
                     BEGIN CASE
                        CASE GUIEVT=GECLICK
                           GOSUB GUI.CREDIT.CREDIT.GRDLINES.CLICK;GUIEVT=0
                     END CASE
                  CASE GUICTL='TXTCRDESC'
                     BEGIN CASE
                        CASE GUIEVT=GEVALIDATE
                           GOSUB GUI.CREDIT.CREDIT.TXTCRDESC.VALIDATE;GUIEVT=0
                     END CASE
                  CASE GUICTL='TXTORDNBR'
                     BEGIN CASE
                        CASE GUIEVT=GEVALIDATE
                           GOSUB GUI.CREDIT.CREDIT.TXTORDNBR.VALIDATE;GUIEVT=0
                     END CASE
               END CASE
         END CASE
   END CASE
   IF GUIEVT THEN
      * Unhandled event - may be dynamic
      GOSUB GUI.DYNAMIC.EVENTS
   END
END ELSE
   GOSUB GUI.CUSTOM.EVENTS
END
RETURN
*-->END EVENT DECODER<--*
*
*
************************************************************
*
*
*-->BEGIN CLOSE EVENT HANDLER<--*
GUI.CREDIT.CREDIT.CLOSE: *
* Default form close event handler
CALL ATGUIHIDE(GUIAPP,GUIFRM,'','',GUIERRORS,GUISTATE)
IF GUIERRORS<1> >= 2 THEN GOTO GUI.ERROR
CALL ATGUIGETPROP(GUIAPP,'','',GPSTATUS,0,0,NUM.FORMS,GUIERRORS,GUISTATE)
IF GUIERRORS<1> >= 2 THEN GOTO GUI.ERROR
IF NUM.FORMS = 0 THEN
   GOSUB GUI.DIALOG.RETURN
   CALL ATGUIDELETE(GUIAPP,'','',GUIERRORS,GUISTATE)
   IF GUIERRORS<1> >= 3 THEN GOTO GUI.ERROR
   GUI.DLG.EXIT = 1
END
RETURN
*-->END CLOSE EVENT HANDLER<--*
*
*
************************************************************
*
*
*-->BEGIN EVENT HANDLER<--*
GUI.CREDIT.CREDIT.BTNCANCEL.CLICK: *
*
* SETUP FOR NEXT CREDIT MEMO
*
GOSUB CLEAR.BUFFERS
GOSUB LOAD.CM.CTRLS
GOSUB LOAD.GRID
RETURN
*-->END EVENT HANDLER<--*
*
*
************************************************************
*
*
*-->BEGIN EVENT HANDLER<--*
GUI.CREDIT.CREDIT.BTNFILE.CLICK: *
*
* CREATE CREDIT MENO (AS CUSTOMER INVOICE WITH NEG VALUE)
*  GET INVOICE #
*  WRITE AR RECORD
*  UNLOCK ALL LOCKED RECORDS
*  PRINT CREDIT MEMO
*
* FIRST CHECK TO SEE IF ALL INFO IS PRESENT
*
GOSUB VALIDATE.CREDIT.MEMO
IF VALID.CREDIT.MEMO THEN
   *
   * GET NEXT INVOICE NUMBER
   *
   CALL NXT.NEXTNBR("AR",AR_ID,ERROR_STATUS,GUIERRORS,GUISTATE)
   IF GUIERRORS<1> >= NXT.GUI.ERROR.LEVEL THEN GOSUB GUI.ERROR
   AR_ID = "CM":AR_ID
   *
   * CREATE THE SALES RECORDS
   *
   GOSUB WRITE.SALES
   * REM MUST RETURN SALES.ID.LIST
   *
   * CONVERT TERMS CODE TO PAYMENT DAYS
   *
   LOCATE OP_REC<OP_SHIP_TERMS> IN TERMS.REC<1> SETTING IDX THEN
      TERM.DAYS = TERMS.REC<3,IDX>
   END ELSE
      TERM.DAYS = 30
   END
   *
   AR_REC = ''
   AR_REC<AR_CUST_ID> =  OP_REC<OP_CUST>
   AR_REC<AR_INV_DATE> = DATE()
   AR_REC<AR_AMOUNT>  = ICONV(-CREDIT.TOTAL,AR_AMOUNT.CNV)
   AR_REC<AR_DUE_DATE> = DATE() + TERM.DAYS
   *
   AR_REC<AR_SALES_ID> = SALES.ID.LIST    ;* NEED THE LIST OF SALES RECORDS CREATED....
   AR_REC<AR_BAL_DUE> = AR_REC<AR_AMOUNT>
   AR_REC<AR_DESC>    = CREDIT.DESC
   CALL WRITE.RECORD(AR_ID,AR_REC,C.AR,@FALSE,ERROR_STATUS)
   *
   * PRINT THE INVOICE (ONLY IF WE ARE NOT USING QUICK_BOOKS FOR THE ACCOUNTING)
   *
   IF NOT(NX_QB_ACCOUNTING) THEN
      CREDITFM = CREDITFORM
      CALL CREDIT.FORM(AR_ID,AR_REC,CREDITFM)

      CREDITFM1 = CREDITFM:ESC:'*p1000x3050Y':COMPANY_REC<COMP_NAME>:ESC:'*p0x0Y'
      IF INVOICE.PRINTER > 0 THEN  ;* PDF PRINT?
         IF NX.PRINT.ENABLE THEN PRINT ON INVOICE.PRINTER CREDITFM1
         IF NX.PRINT.ENABLE THEN PRINTER CLOSE ON INVOICE.PRINTER
         CREDITFM1 = CREDITFM:ESC:'*p1000x3050Y':COMPANY_REC<COMP_NAME>:' Copy':ESC:'*p0x0Y'
         IF NX.PRINT.ENABLE THEN PRINT ON INVOICE.PRINTER CREDITFM1
         IF NX.PRINT.ENABLE THEN PRINTER CLOSE ON INVOICE.PRINTER
      END ELSE
         PDF.NAME = 'CREDIT-':AR_ID:'.PDF'
         DISPLAY.ON.CREATION = @TRUE
         CALL PCL.TO.PDF(CREDITFM1,PDF.NAME,DISPLAY.ON.CREATION,GUIERRORS,GUISTATE)
      END
      *
      * TELL USER ABOUT COMPLETION
      *
      PRMPT = "Credit Memo: ":AR_ID:" created"
      CAPTION = PROG_ID
      STYLE   = 2  ;* !
      BUTTONS = 0  ;* ok
      HELPID = ""
      CALL NXT.ERR.MSG(PRMPT, CAPTION, STYLE, BUTTONS, HELPID, RESPONSE, GUIERRORS,GUISTATE)
   END ELSE
      *
      * FOR QUICK BOOKS ACCOUNTING TELL USER RECORD HAS BEEN CREATED
      *
      PRMPT = "Quick Books Input Record: ":AR_ID:" created for selected sales items"
      CAPTION = PROG_ID
      STYLE   = 2  ;* !
      BUTTONS = 0  ;* ok
      HELPID = ""
      CALL NXT.ERR.MSG(PRMPT, CAPTION, STYLE, BUTTONS, HELPID, RESPONSE, GUIERRORS,GUISTATE)
   END
   *
   * SETUP FOR NEXT CREDIT MEMO
   *
   GOSUB CLEAR.BUFFERS
   GOSUB LOAD.CM.CTRLS
   GOSUB LOAD.GRID
END
RETURN
*-->END EVENT HANDLER<--*
*
*
************************************************************
*
*
*-->BEGIN EVENT HANDLER<--*
GUI.CREDIT.CREDIT.GRDLINES.CLICK: *
GRD.COL = GUIARGS<1,1>
GRD.ROW = GUIARGS<1,2>
IF GRD.ROW LE SALES.DETAIL.COUNT THEN      ;* ONLY ROWS POPULATED WITH SALES DATA
   BEGIN CASE
      CASE GRD.COL = 1    ;* CHECK BOX
         * GET THE ACTUAL STATE FOR THE CHECK BOX IN THIS ROW, NEED TO DO IT THIS WAY INCASE USER CLICK IN CELL BUT MISSES THE BOX
         CALL ATGUIGETPROP(GUIAPP,GUIFRM, "GRDLINES", GPVALUE, GRD.COL, GRD.ROW, INV.SELECTED, GUIERRORS, GUISTATE)
         *
         IF INV.SELECTED THEN ;* CHECKED, INCLUDE
            *
            * SO WHAT WE DO HERE IS GET THE QTY FOR THE CREDIT THEN THE PRICE EACH FOR THE CREDIT
            * WE NEED TO DO THIS BECAUSE CUSTOMER MAY ONLY BE REJECTING A PARTIAL OF THE ORDER
            *
            * THE SIMPLEST IS TO JUST CREATE A DIALOG TO ENTER THE VALUES IN THEIR OWN DIALOG OR
            * MAKE THE QTY CELL FOR THE ROW JUST SELECTED ACTIVE AND WAIT FOR INPUT (BUT THE DIALOG IS LESS TROUBLE PRONE)
            *  TO BE CODED
            *
            IF SALES.DETAIL.LIST<1,GRD.ROW,6> = 'Y' THEN
               LOT.CHARGE  = @TRUE
            END ELSE
               LOT.CHARGE = @FALSE
            END
            M.QTY = SALES.DETAIL.LIST<1,GRD.ROW,5>
            M.PRICE = SALES.DETAIL.LIST<1,GRD.ROW,7>
            CALL CREDIT.AMT.DIALOG(M.QTY,M.PRICE,LOT.CHARGE,GUIERRORS,GUISTATE)
            IF LOT.CHARGE THEN  ;* LOT CHARGE, QTY IS 1
               TOT.AMT = M.PRICE
            END ELSE
               TOT.AMT = M.QTY * M.PRICE
            END
            *
            SALES.DETAIL.LIST<1,GRD.ROW,5> = M.QTY
            SALES.DETAIL.LIST<1,GRD.ROW,7> = M.PRICE
            SALES.DETAIL.LIST<1,GRD.ROW,8> = TOT.AMT"R2"
         END
         SALES.DETAIL.LIST<1,GRD.ROW,1> = INV.SELECTED
         GOSUB LOAD.GRID
         *
   END CASE
END
RETURN
*-->END EVENT HANDLER<--*
*
*
************************************************************
*
*
*-->BEGIN EVENT HANDLER<--*
GUI.CREDIT.CREDIT.TXTCRDESC.VALIDATE: *
CREDIT.DESC = GUIARGS<2>
RETURN
*-->END EVENT HANDLER<--*
*
*
************************************************************
*
*
*-->BEGIN EVENT HANDLER<--*
GUI.CREDIT.CREDIT.TXTORDNBR.VALIDATE: *
* USER ENTERED SALES ORDER NUMBER
*
*  GET THE ORDER RECORD
*  GET THE CUSTOMER RECORD
*  GET THE SHIPTO RECORD
*  LOAD THE FORM
IF GUIARGS<2> # '' THEN
   GOSUB CLEAR.BUFFERS
   OP_ID = GUIARGS<2>
   *
   CALL GET.ORDER.PARENT(OP_ID,OP_REC,@FALSE,ERROR_STATUS,GUIERRORS,GUISTATE)
   BEGIN CASE
      CASE ERROR_STATUS = ERR_NOF  ;* USER ENTERED NON - EXISTENT ORDER #
         *
         PRMPT = "Order number: ":OP_ID:" is not on file"
         CAPTION = PROG_ID
         STYLE   = 2  ;* !
         BUTTONS = 0  ;* ok
         HELPID = ""
         CALL NXT.ERR.MSG(PRMPT, CAPTION, STYLE, BUTTONS, HELPID, RESPONSE, GUIERRORS,GUISTATE)
      CASE 1
         CM_ID = OP_REC<OP_CUST>
         CALL GET.CUSTOMER(CM_ID,CM_REC,@FALSE,ERROR_STATUS,GUIERRORS,GUISTATE)
         *
         IF ERROR_STATUS = ERR_NOF  THEN  ;* WE SHOULD NOT BE HERE WITH CUST
            LOG.OPTS = "DISPLAY"
            ERROR_NBR = ERR_SYS
            ERROR_MSG = 'Selection of non-existent customer from list'
            CALL LOG.ERROR(LOG.OPTS,PROG_ID, ERROR_NBR, ERROR_MSG, GUIERRORS, GUISTATE)
         END ELSE
            GOSUB LOAD.CM.CTRLS
            GOSUB SEL.SALES
            GOSUB LOAD.GRID
         END
   END CASE
END
RETURN
*-->END EVENT HANDLER<--*
*
*
************************************************************
*
*
*-->BEGIN DYNAMIC EVENTS<--*
GUI.DYNAMIC.EVENTS: *
* Add any dynamic event handling code here. The GUIEVT, GUIAPP, GUIFRM,
* GUICTL and GUIARGS variables are valid and availble for your use.
RETURN
*-->END DYNAMIC EVENTS<--*
*
*
************************************************************
*
**-->BEGIN CUSTOM EVENTS<--*
GUI.CUSTOM.EVENTS: *
* Add any custom event handling code here. The GUIEVT, GUIAPP, GUIFRM,
* GUICTL and GUIARGS variables are valid and availble for your use.
RETURN
*-->END CUSTOM EVENTS<--*
*
*
************************************************************
*
**-->BEGIN ERROR HANDLER<--*
GUI.ERROR: *
GUI.DLG.EXIT = 1
LOG.OPTS = "DISPLAY"
ERROR_NBR = ERR_GUI
ERROR_MSG =  ERR_MESSAGE(ERR_GUI)
CALL LOG.ERROR(LOG.OPTS,PROG.ID, ERROR_NBR, ERROR_MSG, GUIERRORS, GUISTATE)
RETURN
*-->END ERROR HANDLER<--*
*
*
************************************************************
SEL.SALES:
*
* SELECT SALES RECORDS ENTERED ORDER
* ON ENTRY:
* OP_ID = ORDER TO CREDIT INVOICE
* ON EXIT
* SALES.DETAIL.LIST POPULATED
*   <1,I,1> = SELECTED FLAG
*   <1,I,2> = INV ID FOR SALES RECORD
*   <1,I,3> = PART NUMBER ON SALES RECORD
*   <1,I,4> = DATE SHIPPED
*   <1,I,5> = QTY SHIPPED
*   <1,I,6> = lot charge y/n
*   <1,I,7> = PRICE EACH
*   <1,I,8> = LINE TOTAL
*   <1,I,9> = GL TRANS CODE
* SALES.TOTAL CACULATED
* SALES.DETAIL.COUNT SET T0 ITEMS IN SALES.DETAIL.LIST
* SA_RECORDS() POPULATED WITH SALES RECORDS TO PROCESS
* NOTE SA_RECORDS(I) AND SALES.DETAIL.LIST<_,I,_> HAVE A ONE TO ONE CORRESPONDANCE
SALES.DETAIL.LIST = ""
MSG_LIST = ""
*
SLIST = 'SSELECT SALES WITH SA_OP_ID = "':OP_ID:'" AND WITH SA_INVOICE_ID # "" AND WITH SA_DEL_QTY # ""  AND WITH SA_CREDIT_MEMO = "" TO 2'
EXECUTE SLIST CAPTURING DMMY.OUT
*
BEGIN CASE
      *
   CASE @SELECTED LT 1
      PRMPT = "No invoiced sales found for order: ":OP_ID
      CAPTION = PROG_ID
      STYLE   = 2  ;* !
      BUTTONS = 0  ;* ok
      HELPID = ""
      CALL NXT.ERR.MSG(PRMPT, CAPTION, STYLE, BUTTONS, HELPID, RESPONSE, GUIERRORS,GUISTATE)
   CASE 1
      READLIST IDLIST FROM 2 THEN
         LIST.CT = DCOUNT(IDLIST,@AM)
         *
         * GET THE SALES RECORDS, )
         *
         DIM SA_RECORDS(LIST.CT)            ;* CREATE AN ARRAY TO HOLD THE SALES RECORDS
         *
         FOR SI = 1 TO LIST.CT
            SA_ID = IDLIST<SI,1>
            CALL GET.RECORD("SALES",C.SALES,SA_ID,SA_RECORDS(SI),@FALSE,ERROR_STATUS,MSG_LIST,GUIERRORS,GUISTATE)
            IF ERROR_STATUS # '' THEN
               *
               * CANNOT GET SALES RECORD, STOP INVOICING
               *
               PRMPT = "Unable to access sales record ":SA_ID:" reason ":ERROR_STATUS
               CAPTION = PROG_ID
               STYLE   = 2  ;* !
               BUTTONS = 0  ;* ok
               HELPID = ""
               CALL NXT.ERR.MSG(PRMPT, CAPTION, STYLE, BUTTONS, HELPID, RESPONSE, GUIERRORS,GUISTATE)
               *
               *
               GOTO SEL.SALES.999
            END ELSE
               SALES.DETAIL.LIST<1,SI,1> = 0 ;* SELECTED FLAG
               SALES.DETAIL.LIST<1,SI,2> = SA_RECORDS(SI)<SA_INVOICE_ID>  ;* INVOICE ID
               SALES.DETAIL.LIST<1,SI,3> = SA_RECORDS(SI)<SA_PART_NBR>    ;* PART NUMBER ON SALES RECORD
               DEL.DATE = SA_RECORDS(SI)<SA_DEL_DATE>
               IF DEL.DATE = '' THEN DEL.DATE = DATE()   ;* FOR EXTRA CHARGES, NO DEL DATE
               SALES.DETAIL.LIST<1,SI,4> = OCONV(DEL.DATE,SA_DEL_DATE.CNV) ;* DATE SHIPPED
               SALES.DETAIL.LIST<1,SI,5> = SA_RECORDS(SI)<SA_DEL_QTY> ;*QTY SHIPPED
               *
               * SET THE PRICE
               *
               IF SA_RECORDS(SI)<SA_LOT_FLAG> THEN ;* LOT CHARGE ??
                  SALES.DETAIL.LIST<1,SI,6> = 'Y'
                  SALES.DETAIL.LIST<1,SI,7> = OCONV(SA_RECORDS(SI)<SA_PRICE_EA>,SA_PRICE_EA.CNV) ;*PRICE EACH
                  SALES.DETAIL.LIST<1,SI,8> = SALES.DETAIL.LIST<1,SI,7>

               END ELSE
                  SALES.DETAIL.LIST<1,SI,6> = 'N'
                  SALES.DETAIL.LIST<1,SI,7> = OCONV(SA_RECORDS(SI)<SA_PRICE_EA>,SA_PRICE_EA.CNV) ;*PRICE EACH
                  SALES.DETAIL.LIST<1,SI,8> = OCONV((SA_RECORDS(SI)<SA_DEL_QTY> * SA_RECORDS(SI)<SA_PRICE_EA>),SA_PRICE_EA.CNV) ;*LINE TOTAL
               END
               *
               SALES.DETAIL.LIST<1,SI,9> = SA_RECORDS(SI)<SA_GL_TRANS_CD>
               *

            END
         NEXT SI
         SALES.DETAIL.COUNT = LIST.CT   ;* SET ITEMS IN SALES.DETAIL.LIST
      END
END CASE
*
SEL.SALES.999: *
RETURN
************************************************************
* $PAGE$
************************************************************
LOAD.GRID: *
*
* ROUTINE UPDATES SALES SELECTION LIST INTO GRDLINES
*
CREDIT.TOTAL = 0
FOR I = 1 TO SALES.DETAIL.COUNT
   IF SALES.DETAIL.LIST<1,I,1> THEN    ;* SELECTED TO CREATE CREDIT?
      CREDIT.TOTAL += SALES.DETAIL.LIST<1,I,8>
   END
NEXT I
*
CTRLIDS = ""
PROPS   = ""
VALUES  = ""
*
CTRLIDS<-1> = 'TXTORDNBR'
PROPS<-1>   = GPVALUE
VALUES<-1>  = OP_ID
*
CTRLIDS<-1> = 'TXTCRDESC'
PROPS<-1>   = GPVALUE
VALUES<-1>  = CREDIT.DESC
*
CTRLIDS<-1> = "GRDLINES"
PROPS<-1>   = GPVALUE
VALUES<-1>  = SALES.DETAIL.LIST
*
CTRLIDS<-1> = "LBLTOTAMT"
PROPS<-1>   = GPVALUE
VALUES<-1>  = CREDIT.TOTAL"R2"
*
CALL ATGUISETPROPS(GUIAPP,GUIFRM,CTRLIDS,PROPS,VALUES,GUIERRORS,GUISTATE)
IF GUIERRORS<1> >= NXT.GUI.ERROR.LEVEL THEN GOSUB GUI.ERROR

RETURN
************************************************************
* $PAGE$
************************************************************
CLEAR.BUFFERS: *
*
OP_ID = ''
OP_REC = ''
CM_ID = ''
CM_REC = ''
*
SALES.DETAIL.COUNT = 0
SALES.DETAIL.LIST = ''
*
CREDIT.TOTAL = 0
CREDIT.DESC  = ''
RETURN
************************************************************
* $PAGE$
************************************************************
LOAD.CM.CTRLS:
*
* routine LOADS controls for customer *
CTRLIDS = ''
PROPS   = ''
VALUES  = ''
*
CTRLIDS<-1> = "LBLBILLCUST"
PROPS<-1>   = GPVALUE
VALUES<-1>  = CM_ID
*
CTRLIDS<-1> = "LBL1BILLNAMEVAL"
PROPS<-1>   = GPVALUE
VALUES<-1>  = CM_REC<CM_NAME>
*
CTRLIDS<-1> = "LBL1BILLADDR1VAL"
PROPS<-1>   = GPVALUE
VALUES<-1>  = CM_REC<CM_ADDR>
*
CTRLIDS<-1> = "LBL1BILLADDR2VAL"
PROPS<-1>   = GPVALUE
VALUES<-1>  = CM_REC<CM_ADDR2>
*
CTRLIDS<-1> = "LBL1BILLCITYVAL"
PROPS<-1>   = GPVALUE
VALUES<-1>  = CM_REC<CM_CITY>
*
CTRLIDS<-1> = "LBL1BILLZIPVAL"
PROPS<-1>   = GPVALUE
VALUES<-1>  = CM_REC<CM_ZIP>
*
CTRLIDS<-1> = "LBL1BILLSTVAL"
PROPS<-1>   = GPVALUE
VALUES<-1>  = CM_REC<CM_STATE>
*
CTRLIDS<-1> = "LBL1BILLCOVAL"
PROPS<-1>   = GPVALUE
VALUES<-1>  = CM_REC<CM_COUNTRY>
*
CALL ATGUISETPROPS(GUIAPP,GUIFRM,CTRLIDS,PROPS,VALUES,GUIERRORS,GUISTATE)
IF GUIERRORS<1> >= NXT.GUI.ERROR.LEVEL THEN GOSUB GUI.ERROR
**
RETURN
************************************************************
* $PAGE$
************************************************************
VALIDATE.CREDIT.MEMO:
* ROUTINE VALIDATES CREDIT MEMO
VALID.CREDIT.MEMO = @TRUE
MSG = ''
BEGIN CASE
   CASE OP_ID = ''
      MSG = 'No Bill To Information Present'
   CASE CREDIT.TOTAL = 0
      MSG = 'No Credit Amount'
   CASE CREDIT.DESC  = ''
      MSG = 'Credit Description Required'
END CASE
IF MSG # '' THEN
   VALID.CREDIT.MEMO = @FALSE
   PRMPT = MSG
   CAPTION = PROG_ID
   STYLE   = 2  ;* !
   BUTTONS = 0  ;* ok
   HELPID = ""
   CALL NXT.ERR.MSG(PRMPT, CAPTION, STYLE, BUTTONS, HELPID, RESPONSE, GUIERRORS,GUISTATE)
END
RETURN
************************************************************
* $PAGE$
************************************************************
WRITE.SALES:
* WRITE SALES RECORDS FOR CM
SALES.ID.LIST = ''   ;* MUST RETURN LIST OF IDS OD SALES RECORDS CREATED
*
FOR I = 1 TO SALES.DETAIL.COUNT
   IF SALES.DETAIL.LIST<1,I,1> THEN    ;* SELECTED TO CREATE CREDIT?
      * REM THERE IS A ONE TO ONE CORRESPONDANCE BETWEEN SALES.DETAIL.LIST (DISPLAYED IN THE GRID) AND
      * SA_RECORDS() ARRAY WHICH HOLDS THE ORIGINAL SALE RECORD FOR THE SALE THE CREDIT IS BEING CREATED FOR.
      * SO WE HAVE THE TEMPLATE FOR THE "NEW" SALES RECORD FOR THE CREDIT
      *

      SA_REC = SA_RECORDS(I)
      SA_REC<SA_INVOICE_ID> = AR_ID
      SA_REC<SA_DEL_QTY> =  SALES.DETAIL.LIST<1,GRD.ROW,5>
      SA_REC<SA_PRICE_EA> = ICONV(SALES.DETAIL.LIST<1,GRD.ROW,7>,SA_PRICE_EA.CNV)
      SA_REC<SA_CREDIT_MEMO> = 'Y'
      *
      CALL NXT.NEXTNBR("SALES",SA_ID,ERROR_STATUS,GUIERRORS,GUISTATE)
      *
      CALL WRITE.RECORD(SA_ID,SA_REC,C.SALES,@FALSE,ERROR_STATUS)
      *
      IF SA_REC<SA_LOT_FLAG> THEN ;* LOT CHARGE ??
         DB_AMT = -SA_REC<SA_PRICE_EA>
      END ELSE
         DB_AMT = -SA_REC<SA_PRICE_EA> * SA_REC<SA_DEL_QTY>
      END
      CR_AMT = DB_AMT
      GL_CODE = SA_REC<SA_GL_TRANS_CD>
      CALL WRITE.GLT(GL_CODE,DB_AMT,CR_AMT,DATE(),"AR-CM",AR_ID:'*':SA_ID,GUIERRORS,GUISTATE)
      *
      SALES.ID.LIST<1,-1> = SA_ID
   END
NEXT I
RETURN
END
