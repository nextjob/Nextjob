SUBROUTINE QADA.DIALOG(GUIERRORS,GUISTATE)
!
**************************************************************************
* This is free and unencumbered software released into the public domain.
*
* Anyone is free to copy, modify, publish, use, compile, sell, or
* distribute this software, either in source code form or as a compiled
* binary, for any purpose, commercial or non-commercial, and by any
* means.
*
* In jurisdictions that recognize copyright laws, the author or authors
* of this software dedicate any and all copyright interest in the
* software to the public domain. We make this dedication for the benefit
* of the public at large and to the detriment of our heirs and
* successors. We intend this dedication to be an overt act of
* relinquishment in perpetuity of all present and future rights to this
* software under copyright law.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
* IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
* OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
* OTHER DEALINGS IN THE SOFTWARE.
*
* For more information, please refer to <https://unlicense.org>
**************************************************************************
*
* MODULE: QADA.DIALOG
* AUTHOR: MAB
* VERSION: 1.0.0
* CREATED: 02/23/2015
* UPDATED:
*
* MAINTENANCE RECORD:
*
*
* EQUATE:
*
*
* VARIABLES:
*
*
* FILES:
*
*
* DESIGN DESCRIPTION:
* DIALOG IS THE DATA ACK ROUTINE FOR QUALITY
* PROCESS:
* USER ENTERS WORK ORDER ID
* USER ENTERS SEQ ID
* USER ENTERS EMP ID
*
* DATA IS VALIDATED (GOOD WO / GOOD SEQ / EMP VALID)
* WORK ORDER ID, SEQ ID AND EMP ID CONTROLS ARE LOCKED
*
* GRID IS POPULATED WITH THE CHARACTERISTICS THAT ARE INSPECTED FOR THE ENTERED SEQ
*
*
* CHARACTERISTIC DATA IS READ  FROM:
*    WITH NXT.EQUATE SETTING: NXT_QA_CHAR_SOURCE SET TO WR, FROM WR FILE AND
*    MAINTAINED VIA RT.DIALOG
*  WITH NXT.EQUATE SETTING: NXT_QA_CHAR_SOURCE SET TO QA_MASTER, FROM QA_MASTER FILE AND
*    CHARACTERISTICS MAINTAINED VIA QAMASTER.DIALOG   
*
* LAST SAMPLE NUMBER IS READ FROM QAD_PARENT (WO*SEQ ID)
* ROUTINE GOES THROUGH EACH ACTIVE CHARACTERISTIC AND DECIDES IF IT IS TO BE ADDED TO THE GRID
*
* USE LOT SIZE (WO QTY) / SAMPLE SIZE (AS CALCULTED FROM AQL TABLE) TO DETETMINE FREQUENCY OF CHARACTERISTIC CHECK
* IE) EVERY PART, EVERY OTHER PART, EVERY 22ND PART
* FROM THIS VALUE AND THE CURRENT SAMPLE VALUE DECIDE IF CHAR IS TO BE ADDED TO THE GRID.
*
* USER ENTERS DATA IN GRID 
* ROUTINE VALIDATES DATA FOR:
* 1) CORRECT DATA TYPE?
*  CANNOT ENTER ACCPT / REJECT FOR A CHARACTERISTIC THAT EXPECTS A NUMBER AND VISE VERSA
* 2) VALUE IN RANGE (FOR NUMBERIC TYPE DATA)
*
* ON FILE CLICK DATA IS WRITEN TO QAD_CHILD RECORD
*  KEY = WO*SEQ*CHAR_ID*SAMPLE#
*  ONE RECORD FOR EACH ROW ON THE CURRENT GRID
*
* GRID IS REFRESHED PRESENTING THE "NEXT" SAMPLES TO TAKE
*
**
DEFFUN GET.SAMPLE.SZ(AQL,LOT.SZ) LOCAL
!
** INCLUDE STANDARD VARIABLE, EQUATES
*
$INCLUDE NXT.INCLUDES NXT.COMMON
$INCLUDE NXT.INCLUDES NXT.EQUATES
$INCLUDE NXT.INCLUDES NXT.ERR.MSGS
$INCLUDE NXT.INCLUDES SYSTEM_FILE.EQU
$INCLUDE NXT.INCLUDES WRT.H
$INCLUDE NXT.INCLUDES WO.H
$INCLUDE NXT.INCLUDES EMPLOYEES.H
$INCLUDE NXT.INCLUDES QAD_PARENT.H
$INCLUDE NXT.INCLUDES QAD_CHILD.H
$INCLUDE NXT.INCLUDES AQL.C0.TABLE
*
$INCLUDE GUIBP ATGUIEQUATES
*
PROG_ID = "QADA.DIALOG"
*
GUIERRORS = ''
* Open the GUI project file
OPEN 'NXT.FORMS' TO GUI.PROJECT.FILE ELSE
   CALL ATGUIERROR(3,'QADA.DIALOG','',0,GRFATAL,"'NXT.FORMS' is not a file name.",GUIERRORS)
   RETURN
END
* Read the GUI template into TEMPLATE
READ TEMPLATE FROM GUI.PROJECT.FILE,'QADA.DIALOG' ELSE
   CALL ATGUIERROR(3,'QADA.DIALOG','',0,GRFATAL,"'QADA.DIALOG' is not on file.",GUIERRORS)
   RETURN
END
* Add your equates and code to open files here...
*
MSG_LIST = ''    ;* GET.RECORD CANNED MESSAGE
* SEED GUI APPLICATION AND GUI FORM VARIABLES AT START UP
GUIAPP = 'QADATAACK'
GUIFRM = 'QADA'
*
************************************************************
*
*
*-->BEGIN GUI HEADER<--*
* If GUISTATE is not NULL, assume GUI has been initialized
IF GUISTATE EQ '' THEN
   CALL ATGUIINIT2(TEMPLATE<2,2>,'',GUIERRORS,GUISTATE)
   IF GUIERRORS<1> >= 3 THEN RETURN
END
* Load the dialog project template
CALL ATGUIRUNMACRO(TEMPLATE,'',GUIERRORS,GUISTATE)
IF GUIERRORS<1> >= 3 THEN RETURN
*-->END GUI HEADER<--*
*
*
************************************************************
*
*
*-->BEGIN GUI STARTUP<--*
ACCEPT = 0 ;* Assume dialog cancelled (update in your OK button Click handler)
* Add your code to load initial values here...
CALL ATGUISHOW('QADATAACK','QADA','','',GUIERRORS,GUISTATE)
IF GUIERRORS<1> >= 2 THEN RETURN
*-->END GUI STARTUP<--*
*
GOSUB STARTUP.STATE
*
************************************************************
*
*
*-->BEGIN EVENT LOOP<--*
GUI.DLG.EXIT = 0
LOOP
   CALL ATGUIWAITEVENT(GUIAPP,GUIFRM,GUICTL,GUIEVT,GUIARGS,GUIERRORS,GUISTATE)
   IF GUIERRORS<1> >= 2 THEN RETURN
   IF GUIEVT EQ GEQUIT THEN
      GUI.DLG.EXIT = 1
   END ELSE
      GUIAPP=OCONV(GUIAPP,'MCU')
      GUIFRM=OCONV(GUIFRM,'MCU')
      GUICTL=OCONV(GUICTL,'MCU')
      GOSUB GUI.DECODE.EVENT
   END
UNTIL GUI.DLG.EXIT DO REPEAT
* Eat final Quit event
IF GUIEVT <> GEQUIT THEN
   GUI.APP.LIST = ''
   CALL ATGUIGETPROP('','','',GPSTATUS,2,0,GUI.APP.LIST,'',GUISTATE)
   IF GUI.APP.LIST EQ '' THEN
      * Quit event fired after last GUI object is deleted - discard it
      CALL ATGUIWAITEVENT('','','','','','',GUISTATE)
      * We could call ATGUISHUTDOWN here if we wanted, but there's no
      * harm just leaving the GUI environment initialized, in case we
      * want to use it again...
   END
END
*-->END EVENT LOOP<--*
*
*
************************************************************
*
*
*-->BEGIN GUI TRAILER<--*
RETURN
*
GUI.DIALOG.RETURN: *
* This subroutine is called just before the GUI Dialog app
* is deleted. Check the state of the ACCEPT variable, and
* retrieve values from GUI controls and assign to appropriate
* arguments for return to calling program here...
IF ACCEPT THEN
   * Add your code here...
END ELSE
   * Add your code here...
END
RETURN
*-->END GUI TRAILER<--*
*
*
************************************************************
*
*
*-->BEGIN EVENT DECODER<--*
GUI.DECODE.EVENT: *
IF NUM(GUIEVT) THEN
   BEGIN CASE
      CASE GUIAPP='QADATAACK'
         BEGIN CASE
            CASE GUIFRM='QADA'
               BEGIN CASE
                  CASE GUICTL=''
                     BEGIN CASE
                        CASE GUIEVT=GECLOSE
                           GOSUB GUI.QADATAACK.QADA.CLOSE;GUIEVT=0
                     END CASE
                  CASE GUICTL='BTNFILE'
                     BEGIN CASE
                        CASE GUIEVT=GECLICK
                           GOSUB GUI.QADATAACK.QADA.BTNFILE.CLICK;GUIEVT=0
                     END CASE
                  CASE GUICTL='BTNNEWWO'
                     BEGIN CASE
                        CASE GUIEVT=GECLICK
                           GOSUB GUI.QADATAACK.QADA.BTNNEWWO.CLICK;GUIEVT=0
                     END CASE
                  CASE GUICTL='BTNRESET'
                     BEGIN CASE
                        CASE GUIEVT=GECLICK
                           GOSUB GUI.QADATAACK.QADA.BTNRESET.CLICK;GUIEVT=0
                     END CASE
                  CASE GUICTL='BTNSTART'
                     BEGIN CASE
                        CASE GUIEVT=GECLICK
                           GOSUB GUI.QADATAACK.QADA.BTNSTART.CLICK;GUIEVT=0
                     END CASE
                  CASE GUICTL='QAGRID'
                     BEGIN CASE
                        CASE GUIEVT=GECLICK
                           GOSUB GUI.QADATAACK.QADA.QAGRID.CLICK;GUIEVT=0
                     END CASE
                  CASE GUICTL='TXTEMPID'
                     BEGIN CASE
                        CASE GUIEVT=GEVALIDATE
                           GOSUB GUI.QADATAACK.QADA.TXTEMPID.VALIDATE;GUIEVT=0
                     END CASE
                  CASE GUICTL='TXTSEQ'
                     BEGIN CASE
                        CASE GUIEVT=GEVALIDATE
                           GOSUB GUI.QADATAACK.QADA.TXTSEQ.VALIDATE;GUIEVT=0
                     END CASE
                  CASE GUICTL='TXTWOID'
                     BEGIN CASE
                        CASE GUIEVT=GEVALIDATE
                           GOSUB GUI.QADATAACK.QADA.TXTWOID.VALIDATE;GUIEVT=0
                     END CASE
               END CASE
         END CASE
   END CASE
   IF GUIEVT THEN
      * Unhandled event - may be dynamic
      GOSUB GUI.DYNAMIC.EVENTS
   END
END ELSE
   GOSUB GUI.CUSTOM.EVENTS
END
RETURN
*-->END EVENT DECODER<--*
*
*
************************************************************
*
*
*-->BEGIN EVENT HANDLER<--*
GUI.QADATAACK.QADA.BTNNEWWO.CLICK: *
GOSUB STARTUP.STATE
RETURN
*-->END EVENT HANDLER<--*
*
*
************************************************************
*
*
*-->BEGIN EVENT HANDLER<--*
GUI.QADATAACK.QADA.BTNRESET.CLICK: *
GOSUB LOAD.QA.GRID
RETURN
*-->END EVENT HANDLER<--*
*
*
************************************************************
*
*
*-->BEGIN EVENT HANDLER<--*
GUI.QADATAACK.QADA.BTNSTART.CLICK: *
*
* DO WE HAVE EVERYTHING TO BEGIN SAMPLE QA DATA ENTRY?
*
MSG = ''
BEGIN CASE
   CASE WO_ID = ''
      MSG = 'Missing Work Order'
   CASE SEQ_ID = ''
      MSG = 'Missing Seq Number'
   CASE EMP_ID = ''
      MSG = 'Missing Employee Id'
END CASE
IF MSG # '' THEN
   PRMPT = MSG:', Please Correct'
   STYLE   = 2  ;* !
   BUTTONS = 0  ;* ok
   HELPID = ""
   CALL NXT.ERR.MSG(PRMPT, PROG_ID, STYLE, BUTTONS, HELPID, RESPONSE, GUIERRORS,GUISTATE)
END ELSE
   *
   * ARE THERE CHARACTERISTICS FOR THIS SEQ?
   QA.CNT = DCOUNT(WRT_REC<WRT_QA_CHAR>,@VM)
   IF QA.CNT > 0 THEN
      *
      * START THE DATA COLLECTION PROCESS
      * LOOK FOR A QAD_PARENT RECORD
      *
      QAP_ID = WO_ID:'*':SEQ_ID
      CALL GET.RECORD("QAD_PARENT",C.QAD_PARENT,QAP_ID,QAP_REC,@FALSE,ERROR_STATUS,MSG_LIST,GUIERRORS,GUISTATE)
      IF ERROR_STATUS = ERR_NOF THEN
         SAMPLE.COUNT = 1
      END ELSE
         SAMPLE.COUNT = QAP_REC<QAP_LAST_SAMPLE> + 1
      END
      *
      FORM.STATE = 'COLLECT'
      GOSUB SET.FORM.STATE
      GOSUB LOAD.QA.GRID    ;* START COLLECTING DATA
   END ELSE
      PRMPT = "No Characterisitcs Defined On This Sequence"
      STYLE   = 2  ;* !
      BUTTONS = 0  ;* ok
      HELPID = ""
      CALL NXT.ERR.MSG(PRMPT, PROG_ID, STYLE, BUTTONS, HELPID, RESPONSE, GUIERRORS,GUISTATE)
   END
END
RETURN
*-->END EVENT HANDLER<--*
*
*
************************************************************
*
*
*-->BEGIN CLOSE EVENT HANDLER<--*
GUI.QADATAACK.QADA.CLOSE: *
* Default form close event handler
CALL ATGUIHIDE(GUIAPP,GUIFRM,'','',GUIERRORS,GUISTATE)
IF GUIERRORS<1> >= 2 THEN GOTO GUI.ERROR
CALL ATGUIGETPROP(GUIAPP,'','',GPSTATUS,0,0,NUM.FORMS,GUIERRORS,GUISTATE)
IF GUIERRORS<1> >= 2 THEN GOTO GUI.ERROR
IF NUM.FORMS = 0 THEN
   GOSUB GUI.DIALOG.RETURN
   CALL ATGUIDELETE(GUIAPP,'','',GUIERRORS,GUISTATE)
   IF GUIERRORS<1> >= 3 THEN GOTO GUI.ERROR
   GUI.DLG.EXIT = 1
END
RETURN
*-->END CLOSE EVENT HANDLER<--*
*
*
************************************************************
*
*
*-->BEGIN EVENT HANDLER<--*
GUI.QADATAACK.QADA.BTNFILE.CLICK: *
IF CHAR.CT > 0 THEN
   *
   * REVALIDATE DATA HERE?
   *
   MSG = ''
   FOR I = 1 TO CHAR.CT
      IF QA.LIST<1,I,7> = "" THEN
         MSG = 'Char Id: ':QA.LIST<1,I,1>:' Has Not Been Assigned a Value!'
         PRMPT = MSG
         STYLE   = 2  ;* !
         BUTTONS = 0  ;* ok
         HELPID = ""
         CALL NXT.ERR.MSG(PRMPT, PROG_ID, STYLE, BUTTONS, HELPID, RESPONSE, GUIERRORS,GUISTATE)
         EXIT
      END
   NEXT I
   IF MSG = '' THEN   ;* ALL ENTERED AND VALID

      *
      * ACCESS QAD_PARENT RECORD TO DETERMINE DATA GROUP #
      CALL GET.RECORD("QAD_PARENT",C.QAD_PARENT,QAP_ID,QAP_REC,@TRUE,ERROR_STATUS,NXT.CANCEL.ON.LOCKED,GUIERRORS,GUISTATE)
      IF ERROR_STATUS = ERR_BUSY THEN
         NULL
      END ELSE
*         
         IF ERROR_STATUS = ERR_NOF THEN   ;* IF NOT FOUND, CREATE IT
            QAP_REC = ''
            QAP_REC<QAP_SAMPLE_START_DATE> = DATE()
         END ELSE
            IF QAP_REC<QAP_LAST_SAMPLE> GE SAMPLE.COUNT THEN   ;* SEE NOTE BELOW!
               SAMPLE.COUNT = QAP_REC<QAP_LAST_SAMPLE> + 1
            END 
         END
         QAP_REC<QAP_LAST_SAMPLE> = SAMPLE.COUNT
         QAP_REC<QAP_LAST_SAMPLE_DATE> = DATE()
         QAP_REC<QAP_LAST_SAMPLE_TIME> = TIME()
         QAP_REC<QAP_PARTNBR> = WO_REC<WO_PARTNBR>
         *
         * NOTE THERE IS A HOLE IN THE LOGIC HERE
         * IF MORE THAN 1 USER IS ENTERING DATA TO THIS QAD_PARENT RECORD (SAME WO & SEQ) YOU COULD END UP WITH QAP_REC<QAP_LAST_SAMPLE>
         * BEING INCREMENTED FOR ONE OF THE USERS DURING A SAMPLING SESSION AND THERE BY BEING OUT OF SYNC FOR THE OTHER USER
         * (QAP_REC<QAP_LAST_SAMPLE> COULD BE GE TO THIS USERS SAMPLE.COUNT)
         * TO KEEP FROM OVERWRITING QAD_CHILD RECORDS WE INCREMENT THIS SAMPLE'S COUNT TO THE NEXT CHILD SAMPLE NUMBER
         * THIS WOULD MEAN THAT THE SAMPLE FREQUENCE CALCULATION WOULD BE INCORRECT AND YOU COULD END UP WITH MORE
         * DATA SAMPLES THAN THE SAMPLE PLAN REQUIRES.  DATA WILL NOT BE LOST ONLY EXTRA DATA WOULD BE TAKEN
         *
         *
         * WRITE QAD_CHILD RECORD
         *
         FOR I = 1 TO CHAR.CT
            QAC_ID = QAP_ID:'*':QA.LIST<1,I,1>:'*':SAMPLE.COUNT
            QAC_REC = ''
            QAC_REC<QAC_DATE> = DATE()
            QAC_REC<QAC_TIME> = TIME()
            QAC_REC<QAC_EMP> = EMP_ID
            QAC_REC<QAC_VALUE> = QA.LIST<1,I,7>
            CALL WRITE.RECORD(QAC_ID,QAC_REC,C.QAD_CHILD,@FALSE,ERROR_STATUS)
         NEXT I
         *
         *WRITE OUT PARENT RECORD
         *
         CALL WRITE.RECORD(QAP_ID,QAP_REC,C.QAD_PARENT,@FALSE,ERROR_STATUS)
         * CLEAR GRID OF VALUE DATA FOR NEXT SAMPLE
         SAMPLE.COUNT += 1
         GOSUB LOAD.QA.GRID
         *
      END
   END
END
RETURN
*-->END EVENT HANDLER<--*
*
*
************************************************************
*
*
*-->BEGIN EVENT HANDLER<--*
GUI.QADATAACK.QADA.QAGRID.CLICK: *
*the user clicked the left mouse button on this control. GUIARGS<1,1> is the
*column number and GUIARGS<1,2> is the row number of the cell clicked
COL = GUIARGS<1,1>
ROW = GUIARGS<1,2>
*
CHAR_ID   = QA.LIST<1,ROW,1>
CHAR_TEXT = QA.LIST<1,ROW,2>
CHAR_VAL1 = QA.VALUES<ROW,1>  ;* SAVE LIMIT VALUES (NEED TO DECIDE IF THEY WILL BE DISPLAYED)
CHAR_VAL2 = QA.VALUES<ROW,2>
IF CHAR_VAL1 # '' THEN  ;* IS THERE CHARACTERISTIC DATA ON THIS ROW?
   *
   CALL QADATAENTRY.DIALOG(CHAR_ID,CHAR_TEXT,CHAR_VAL1,CHAR_VAL2,USER_VAL,GUIERRORS,GUISTATE)
   *
   * STUFF USER DATA INTO GRID
   *
   IF USER_VAL # '' THEN
      QA.LIST<1,ROW,7> = USER_VAL
      CALL ATGUISETPROP(GUIAPP,GUIFRM,"QAGRID",GPVALUE,COL,ROW,USER_VAL,GUIERRORS,GUISTATE)
   END
END
RETURN
*-->END EVENT HANDLER<--*
*
*
************************************************************
*
*
*-->BEGIN EVENT HANDLER<--*
GUI.QADATAACK.QADA.TXTEMPID.VALIDATE: *
EMP_ID  = TRIM(GUIARGS<2>)
CALL GET.RECORD("EMPLOYEES",C.EMPLOYEES,EMP_ID,EMP_REC,@FALSE,ERROR_STATUS,MSG_LIST,GUIERRORS,GUISTATE)
IF ERROR_STATUS = ERR_NOF THEN
   PRMPT = EMP_ID:' Is Not On File, Retry'
   STYLE   = 2  ;* !
   BUTTONS = 0  ;* ok
   HELPID = ""
   CALL NXT.ERR.MSG(PRMPT, PROG_ID, STYLE, BUTTONS, HELPID, RESPONSE, GUIERRORS,GUISTATE)
   EMP_ID = ''
END
GOSUB LOAD.WO.CTRLS
*
RETURN
*-->END EVENT HANDLER<--*
*
*
************************************************************
*
*
*-->BEGIN EVENT HANDLER<--*
GUI.QADATAACK.QADA.TXTSEQ.VALIDATE: *
*
SEQ_ID = TRIM(GUIARGS<2>)
*
IF WO_ID = '' THEN
   PRMPT = 'Work Order Entry Required Before Seq'
   STYLE   = 2  ;* !
   BUTTONS = 0  ;* ok
   HELPID = ""
   CALL NXT.ERR.MSG(PRMPT, PROG_ID, STYLE, BUTTONS, HELPID, RESPONSE, GUIERRORS,GUISTATE)
   SEQ_ID = ''
   GOSUB LOAD.WR.CTRLS
END ELSE
   WR_ID = WO_ID:"*":SEQ_ID
   CALL GET.RECORD("WR",C.WR,WR_ID,WRT_REC,@FALSE,ERROR_STATUS,MSG_LIST,GUIERRORS,GUISTATE)
   IF ERROR_STATUS = ERR_NOF THEN
      PRMPT = SEQ_ID:' Is Not a Valid Work Order Seq, Retry'
      STYLE   = 2  ;* !
      BUTTONS = 0  ;* ok
      HELPID = ""
      CALL NXT.ERR.MSG(PRMPT, PROG_ID, STYLE, BUTTONS, HELPID, RESPONSE, GUIERRORS,GUISTATE)
      SEQ_ID = ''
      GOSUB LOAD.WR.CTRLS
   END ELSE
      GOSUB LOAD.WR.CTRLS
      * SET MAX.SAMPLE.WARNING BASED ON WORK ORDER QTY
      QTY.TO.MFG = WRT_REC<WR_QTY_TO_MFG>
      BEGIN CASE
         CASE QTY.TO.MFG LE 5
            MAX.SAMPLE.WARNING = 1.75   ;*
         CASE QTY.TO.MFG LE 10
            MAX.SAMPLE.WARNING = 1.55   ;*
         CASE QTY.TO.MFG LE 20
            MAX.SAMPLE.WARNING = 1.45   ;*
         CASE QTY.TO.MFG LE 25
            MAX.SAMPLE.WARNING = 1.40   ;*
         CASE QTY.TO.MFG LE 30
            MAX.SAMPLE.WARNING = 1.35   ;*
         CASE QTY.TO.MFG LE 40
            MAX.SAMPLE.WARNING = 1.3   ;*
         CASE QTY.TO.MFG LE 60
            MAX.SAMPLE.WARNING = 1.20   ;*
         CASE QTY.TO.MFG LE 80
            MAX.SAMPLE.WARNING = 1.15   ;*
         CASE QTY.TO.MFG LE 100
            MAX.SAMPLE.WARNING = 1.10   ;*
         CASE QTY.TO.MFG LE 150
            MAX.SAMPLE.WARNING = 1.08   ;*
         CASE QTY.TO.MFG LE 200
            MAX.SAMPLE.WARNING = 1.07   ;*
         CASE QTY.TO.MFG LE 300
            MAX.SAMPLE.WARNING = 1.03   ;*
         CASE QTY.TO.MFG LE 500
            MAX.SAMPLE.WARNING = 1.02   ;*
         CASE QTY.TO.MFG LE 750
            MAX.SAMPLE.WARNING = 1.015  ;*
         CASE QTY.TO.MFG LE 1000
            MAX.SAMPLE.WARNING = 1.012   ;*
         CASE QTY.TO.MFG LE 1500
            MAX.SAMPLE.WARNING = 1.011   ;*
         CASE 1
            MAX.SAMPLE.WARNING = 1.008   ;*
      END CASE
   END
END
RETURN
*-->END EVENT HANDLER<--*
*
*
************************************************************
*
*
*-->BEGIN EVENT HANDLER<--*
GUI.QADATAACK.QADA.TXTWOID.VALIDATE: *
WO_ID = TRIM(GUIARGS<2>)
CALL GET.RECORD("WO",C.WO,WO_ID,WO_REC,@FALSE,ERROR_STATUS,MSG_LIST,GUIERRORS,GUISTATE)
IF ERROR_STATUS = ERR_NOF THEN
   PRMPT = WO_ID:' Is Not a Valid Work Order, Retry'
   STYLE   = 2  ;* !
   BUTTONS = 0  ;* ok
   HELPID = ""
   CALL NXT.ERR.MSG(PRMPT, PROG_ID, STYLE, BUTTONS, HELPID, RESPONSE, GUIERRORS,GUISTATE)
   WO_ID = ''
END
**
* WHEN EVER USER ENTERS NEW WORK ORDER RESET SEQ ID AND SEQ RECORD
*
SEQ_ID = ''
WRT_REC = ''
GOSUB LOAD.WO.CTRLS
RETURN
*-->END EVENT HANDLER<--*
*
*
************************************************************
*
*
*-->BEGIN DYNAMIC EVENTS<--*
GUI.DYNAMIC.EVENTS: *
* Add any dynamic event handling code here. The GUIEVT, GUIAPP, GUIFRM,
* GUICTL and GUIARGS variables are valid and availble for your use.
RETURN
*-->END DYNAMIC EVENTS<--*
*
*
************************************************************
*
**-->BEGIN CUSTOM EVENTS<--*
GUI.CUSTOM.EVENTS: *
* Add any custom event handling code here. The GUIEVT, GUIAPP, GUIFRM,
* GUICTL and GUIARGS variables are valid and availble for your use.
RETURN
*-->END CUSTOM EVENTS<--*
*
*
************************************************************
*
**-->BEGIN ERROR HANDLER<--*
GUI.ERROR: *
GUI.DLG.EXIT = 1
LOG.OPTS = "DISPLAY"
ERROR_NBR = ERR_GUI
ERROR_MSG =  ERR_MESSAGE(ERR_GUI)
CALL LOG.ERROR(LOG.OPTS,PROG_ID, ERROR_NBR, ERROR_MSG, GUIERRORS, GUISTATE)
RETURN
*-->END ERROR HANDLER<--*
*
*****************************************************************************************
CLEAR.BUFFERS:
WO_ID = ''
SEQ_ID = ''
WO_REC = ''
WRT_REC = ''
EMP_ID = ''
EMP_REC = ''
FORM.STATE = 'STARTUP'
SAMPLE.COUNT = 0
CHAR.CT = 0   ;* ENTRIES IN QAGRID
RETURN
*
*****************************************************************************************
STARTUP.STATE:
GOSUB CLEAR.BUFFERS
GOSUB LOAD.WO.CTRLS
GOSUB LOAD.WR.CTRLS
GOSUB LOAD.QA.GRID
GOSUB SET.FORM.STATE
RETURN
*****************************************************************************************
SET.FORM.STATE:
IF FORM.STATE = 'STARTUP' THEN
   FRMDATA.STATE = 0
   FRMWO.STATE = 1
END ELSE
   FRMDATA.STATE = 1
   FRMWO.STATE = 0
END
CTRLIDS = ''
PROPS   = ''
VALUES  = ''
*
CTRLIDS<1> = "FRMDATA"
PROPS<1>   = GPENABLED
VALUES<1>  = FRMDATA.STATE
*
CTRLIDS<2> = "FRMWO"
PROPS<2>   = GPENABLED
VALUES<2>  = FRMWO.STATE
*
CALL ATGUISETPROPS(GUIAPP,GUIFRM,CTRLIDS,PROPS,VALUES,GUIERRORS,GUISTATE)
*
IF GUIERRORS<1> >= NXT.GUI.ERROR.LEVEL THEN GOSUB GUI.ERROR
RETURN
******************************************************************************************
LOAD.WR.CTRLS:

*
* routine LOADS controls (DELETE THIS ROUTING FOR SPECING ONLY?
*
CTRLIDS = ''
PROPS   = ''
VALUES  = ''

*
CTRLIDS<1> = "TXTSEQ"
PROPS<1>   = GPVALUE
VALUES<1>  = SEQ_ID
*
CTRLIDS<2> = "LBLWOQTYVAL"
PROPS<2>   = GPVALUE
VALUES<2>  = WRT_REC<WR_QTY_TO_MFG>
*
*
CALL ATGUISETPROPS(GUIAPP,GUIFRM,CTRLIDS,PROPS,VALUES,GUIERRORS,GUISTATE)
*
IF GUIERRORS<1> >= NXT.GUI.ERROR.LEVEL THEN GOSUB GUI.ERROR


RETURN
******************************************************************************************
LOAD.WO.CTRLS:
*
* routine LOADS WO controls
*
*
CTRLIDS = ''
PROPS   = ''
VALUES  = ''
*
CTRLIDS<1> = "TXTWOID"
PROPS<1>   = GPVALUE
VALUES<1>  = WO_ID
*
CTRLIDS<2> = "LBLPNV"
PROPS<2>   = GPVALUE
VALUES<2>  = WO_REC<WO_PARTNBR>
*
CTRLIDS<3> = "LBLDESCV"
PROPS<3>   = GPVALUE
VALUES<3>  = WO_REC<WO_PT_DESC>
*
CTRLIDS<4> = "LBLDRAWV"
PROPS<4>   = GPVALUE
VALUES<4>  = WO_REC<WO_PT_DRAWING>
*
CTRLIDS<5> = "TXTEMPID"
PROPS<5>   = GPVALUE
VALUES<5>  = EMP_ID
*
CTRLIDS<6> = "LBLEMPNAME"
PROPS<6>   = GPVALUE
VALUES<6>  = EMP_REC<EMP_LAST_NAME>:' ':EMP_REC<EMP_FIRST_NAME>
*
CALL ATGUISETPROPS(GUIAPP,GUIFRM,CTRLIDS,PROPS,VALUES,GUIERRORS,GUISTATE)
*
IF GUIERRORS<1> >= NXT.GUI.ERROR.LEVEL THEN GOSUB GUI.ERROR
RETURN
******************************************************************************************
LOAD.QA.GRID: *
*
* DISPLAY SAMPLE COUNT
CALL ATGUISETPROP(GUIAPP,GUIFRM, "LBLSAMPLEVAL", GPVALUE, 0, 0,SAMPLE.COUNT, GUIERRORS, GUISTATE)
*
* POPULATE QA GRID
*
QA.LIST = ''
QA.VALUES = ''
CHAR.CT = 0
QA.CNT = DCOUNT(WRT_REC<WRT_QA_CHAR>,@VM)
*
FOR I = 1 TO QA.CNT
   IF WRT_REC<WRT_QA_ACTIVE,I> THEN  ;* CHARACTERISTIC IS MARKED ACTIVE
      *
      AQL = WRT_REC<WRT_QA_AQL,I>
      QTY.TO.MFG = WRT_REC<WR_QTY_TO_MFG>
      SAMPLE.SZ = GET.SAMPLE.SZ(AQL,QTY.TO.MFG)  ;* DETERMINE SAMPLE SIZE BASED ON WORK ORDER QTY AND AQL %
      IF SAMPLE.SZ GE 0 THEN  ;* TEST FOR GOOD SAMPLE SIZE LOOK UP (IF NEG THERE WAS AN ERROR)
         *
         *         IF SAMPLE.SZ = 0 THEN  ;* SAMPLE SIZE = 0 MEANS ALL PARTS ARE CHECK FOR THIS CHARACTERISTIC
         *            INSPECT = @TRUE
         *         END ELSE
         SAMPLE.FREQ = INT(QTY.TO.MFG /SAMPLE.SZ)    ;* CALCULATE INTERVAL TO SAMPLE
         IF REM(SAMPLE.COUNT , SAMPLE.FREQ) THEN     ;* USE REM FUNCTION TO SEE IF ITS TIME TO SAMPLE THIS CHARACTERISTIC
            INSPECT = @FALSE                         ;* NOT TIME TO TAKE THIS SAMPLE
         END ELSE
            INSPECT = @TRUE
         END
         *        END
         IF INSPECT THEN
            CHAR.CT += 1
            QA.LIST<1,CHAR.CT,1> = WRT_REC<WRT_QA_CHAR_ID,I>    ;* CHARACTERISTIC id
            QA.LIST<1,CHAR.CT,2> = WRT_REC<WRT_QA_CHAR,I>    ;* CHARACTERISTIC
            QA.LIST<1,CHAR.CT,3> = SAMPLE.SZ
            QA.LIST<1,CHAR.CT,4> = SAMPLE.FREQ
            QA.LIST<1,CHAR.CT,5> = WRT_REC<WRT_QA_LOC,I>     ;* LOCATION ON PRINT
            QA.LIST<1,CHAR.CT,6> = WRT_REC<WRT_QA_METHOD,I>  ;* INSPECTION METHOD
            QA.LIST<1,CHAR.CT,7> = ""                        ;* VALUE
            *
            QA.VALUES<CHAR.CT,1> = WRT_REC<WRT_QA_VAL1,I>    ;* SAVE LIMIT VALUES (NEED TO DECIDE IF THEY WILL BE DISPLAYED)
            QA.VALUES<CHAR.CT,2> = WRT_REC<WRT_QA_VAL2,I>    ;* BUT WILL BE HELPFUL FOR VALIDATION
         END
      END ELSE
         LOG.OPTS = "DISPLAY"
         ERROR_NBR = ERR_SYS
         ERROR_MSG =  "Error in AQL Sample Sz Calculation, ":WR_ID:" Char Id ":WRT_REC<WRT_QA_CHAR_ID,I>
         CALL LOG.ERROR(LOG.OPTS,PROG_ID, ERROR_NBR, ERROR_MSG, GUIERRORS, GUISTATE)
      END
   END
NEXT I
*
* IF THERE IS NOT AT LEAST 1 CHARACTERISTIC TO INSPECT ON THIS SAMPLE COUNT WE NEED TO SKIP TO NEXT SAMPLE
* AND TRY AGAIN
*
IF QA.CNT > 0 AND CHAR.CT = 0 THEN
   SAMPLE.COUNT += 1
   IF SAMPLE.COUNT > (QTY.TO.MFG * MAX.SAMPLE.WARNING) THEN  ;* THIS TEST IS TO PREVENT AN ENDLESS LOOP LOOKING FOR THE NEXT SAMPLE
      PRMPT = 'Sample Count Has Exceeded Work Order Qty Calculated Threshold, Continue Sampling?'
      STYLE   = 2  ;* !
      BUTTONS = 1  ;* ok / cancel
      HELPID = ""
      CALL NXT.ERR.MSG(PRMPT, PROG_ID, STYLE, BUTTONS, HELPID, RESPONSE, GUIERRORS,GUISTATE)
      IF RESPONSE = NXT.CANCEL.RSP THEN
         GOTO LOAD.QA.GRID.999
      END
   END
   GOTO LOAD.QA.GRID
END
*

*
CTRLIDS = "QAGRID"
PROPS   = GPVALUE
VALUES  = QA.LIST
*
CALL ATGUISETPROPS(GUIAPP,GUIFRM,CTRLIDS,PROPS,VALUES,GUIERRORS,GUISTATE)
IF GUIERRORS<1> >= NXT.GUI.ERROR.LEVEL THEN GOSUB GUI.ERROR
*
**
*
LOAD.QA.GRID.999: *
RETURN
**********************************************************************************************************
**********************************************************************************************************
LOCAL FUNCTION GET.SAMPLE.SZ(AQL,LOT.SZ)
PRIVATE SS
*
* AQL SPECIFIES THE AQL %, USED AS LOOKUP VALUE INTO AQL.C0.IDX (DEFINED IN NXT.INCLUDES AQL.C0.TABLE)
* TO FIND INDEX INTO THE AQL.C0.TABLE FOR THE AQL %
* LOT.SZ IS THE LOT SIZE WE ARE INSPECTING
* RETURNS SAMPLE SIZE
* sample size is found by locating the lot size in the AQL.C0.TABLE<AQL%> defined in NXT.INCLUDES AQL.C0.TABLE
BEGIN CASE
   CASE LOT.SZ LE 0
      SS = -1
   CASE LOT.SZ EQ 1
      SS = 1
   CASE 1
      LOCATE AQL IN AQL.C0.IDX<1> SETTING AQL.IDX THEN
         LOCATE LOT.SZ IN AQL.C0.TABLE<AQL.LOTSZ,1> BY "AR" SETTING LOT.IDX THEN
            SS = AQL.C0.TABLE<AQL.IDX,LOT.IDX>   ;* FOUND EXACT LOT SIZE
            IF SS = 'ALL' THEN SS = LOT.SZ

         END ELSE
            SS =  AQL.C0.TABLE<AQL.IDX,LOT.IDX-1>
            IF SS = 'ALL' THEN SS = LOT.SZ

         END
      END ELSE
         SS = -1
      END
END CASE
RETURN SS
END
**********************************************************************************************************************
END
