SUBROUTINE WRT.FORWARD.SCHD(START.DT,MAT SEQ.ARRAY,EXCPT,SHP.CAL)
!
**************************************************************************
* This is free and unencumbered software released into the public domain.
*
* Anyone is free to copy, modify, publish, use, compile, sell, or
* distribute this software, either in source code form or as a compiled
* binary, for any purpose, commercial or non-commercial, and by any
* means.
*
* In jurisdictions that recognize copyright laws, the author or authors
* of this software dedicate any and all copyright interest in the
* software to the public domain. We make this dedication for the benefit
* of the public at large and to the detriment of our heirs and
* successors. We intend this dedication to be an overt act of
* relinquishment in perpetuity of all present and future rights to this
* software under copyright law.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
* IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
* OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
* OTHER DEALINGS IN THE SOFTWARE.
*
* For more information, please refer to <https://unlicense.org>
**************************************************************************
*
* MODULE: WRT.FORWARD.SCHD
* AUTHOR: MAB
* VERSION: 1.0.0
* CREATED: 03/01/2014
* UPDATED:
*
* MAINTENANCE RECORD:
*
* EQUATE:
*
*
* VARIABLES:
* START.DT  - DATE TO SCHEDULE FROM
* WO_ID  -  WORK ORDER ID
* EXCPT   - EXCEPTIONS REPORT
* SHP.CAL - SHOP CALENDAR
*
*
* DESIGN DESCRIPTION:
* ROUTINE PERFORMS BACKWARD SCHEDULE ON PASSED ROUTING FILE
*
* * * ASSUMES CALLER HAS LOCKED THE WORK ORDER RECORD FOR WO_ID ***
* * * ASSUMES CALLER HAS POPULATED SEQ.ARRAY WITH THE CALL:
* OPTS = 1
* CALL WO.GRDRT.UPDATE(WO_ID,MAT SEQ.ARRAY,WR.COUNT,OPTS,"","","","","")
* RETURNS -  SEQ.ARRAY WITH THE FOLLOWING INFORMATION FOR EACH SEQ:
*
* * * ROUTINE DOES NOT WRITE BACK TO WR RECORDS, ONLY UPDATES SEQ.ARRAY WITH DATA
* * * CALLERS RESPONSIBILITY TO PULL DATA BACK OUT OF SEQ.ARRAY AND POPULATE ASSOCIATED WR RECORDS
*
*
*       NEXTJOB NOTES
*
*         WE HAVE BOTH EMP AND MACHINE HOURS DEFINE ON RT / WRT RECORD
*         THE WAY WE SCHEDULE DEPENDS ON WRT_SCHDCONCURRENT SETTING ON THE RECORD
*             IF SET, THE LOAD IS SCHEDULED CONCURRENTLY (IE SCHEDULED TO THE LONGEST SETUP TIME, LONGEST RUN TIME)
*             IF NOT SET EMP SU THEN MACHINE SU IS SCHEDULED THEN  EMP RUN AND FINALLY MACHINE RUN
*
*             DO NOT CONFUSE WITH TACK EMP / MACHINE SEPARATE THIS HAS TO DO WITH COSTING AND LABOR TICKET CREATION,
*             ALSO MEANS WE CREATE LOADING FOR BOTH THE EMP (WC#_EMP) AND MACHINE (WC#_MACH)
*
*
!
** INCLUDE STANDARD VARIABLE, EQUATES
*
$INCLUDE NXT.INCLUDES NXT.COMMON
$INCLUDE NXT.INCLUDES NXT.EQUATES
$INCLUDE NXT.INCLUDES NXT.WO.STATUS.DEF
$INCLUDE NXT.INCLUDES WR.H
**
PGM.NAME = "WRT.FORWARD.SCHD"
*
DIM SEQ.ARRAY(1,1)  ;* DUMMY DECLARATION OF SEQ INFO ARRAY*
* INIT
SEQ.INF = ''
S.DATE = START.DT
E.DATE = START.DT
*
S.HRS  = 0            ;* HOURS USED ON S.DATE
E.HRS  = 0
EXCPT  = ''           ;* EXCEPTIONS REPORT
*
*
* GET THE SEQ STATUS CODES
*
NS =  WORK.ORDER.SEQ.STATUS.LIST<1,WO.NS.IDX,1>
QU =  WORK.ORDER.SEQ.STATUS.LIST<1,WO.Q.IDX,1>
SU =  WORK.ORDER.SEQ.STATUS.LIST<1,WO.SU.IDX,1>
SC =  WORK.ORDER.SEQ.STATUS.LIST<1,WO.SC.IDX,1>
RN =  WORK.ORDER.SEQ.STATUS.LIST<1,WO.RN.IDX,1>
CMP = WORK.ORDER.SEQ.STATUS.LIST<1,WO.C.IDX,1>
RJT =   WORK.ORDER.SEQ.STATUS.LIST<1,WO.RJ.IDX,1>
*
*
* DETERMINE NUMBER OF ROUTING SEQS
* COUNT ROWS (VIA SEQ.ARRAY DATA)
ROWS = INMAT(SEQ.ARRAY)
SEQ.COUNT = ROWS<1,1>
!
* PASS 1 - CALCULATE LOAD HOURS
!
*
* DETERMINE HOURS OF LOAD FROM THIS SEQ
*
CALL WRT.LOAD.CALC(SEQ.COUNT,MAT SEQ.ARRAY,SHP.CAL,NS,QU,SU,SC,CMP)
*
!
* PASS 2 - FWD SCHD
!
FOR I =  1 TO SEQ.COUNT
  *
  EMP.LOAD.HRS  = SEQ.ARRAY(I,SQI_EMPL)
  MACH.LOAD.HRS  = SEQ.ARRAY(I,SQI_MCHL)
  COMP      = SEQ.ARRAY(I,SQI_SCHST)
  SEQRN     = SEQ.ARRAY(I,SQI_SCHRN)
  *
  IF ((EMP.LOAD.HRS + MACH.LOAD.HRS) LE 0) AND (NOT(COMP)) THEN
    COMP = @TRUE  ;* IF NO LOAD HOURS FORCE TO COMPLETE
  END
  *
  IF COMP THEN    ;* SEQ COMP ?
    SEQ.ARRAY(I,SQI_NSTR) = E.DATE  ;*YES, MARK SEQ CMP, USE LAST SCHD DATE
    SEQ.ARRAY(I,SQI_NEND) = E.DATE
    SEQ.ARRAY(I,SQI_STAT) = CMP
  END ELSE        ;* NO, SCHEDULE THIS SEQ
    *
    IF I = 1 THEN   ;* FIRST SEQ
      SEQRN   = @TRUE
      PDEPT   = SEQ.ARRAY(I,SQI_DEP)
      PWC.NBR = SEQ.ARRAY(I,SQI_WC)
    END ELSE
      *
      * FIND PREV SEQ
      PRV = I - 1    ;* INDEX TO PREV SEQ INFO IN SEQ.INF
CMP.030: *      *
     
      *
      IF PRV LE 0 THEN     ;* SCAN THRU TO TOP, SETUP FOR NO PRV
        SEQRN     = @TRUE
        PDEPT = SEQ.ARRAY(1,SQI_DEP)
        PWC.NBR = SEQ.ARRAY(1,SQI_WC)
      END ELSE
        PRV.CMP = SEQ.ARRAY(PRV,SQI_SCHST)     ;* PRV SEQ COMP FLAG
        IF (SEQ.ARRAY(PRV,SQI_EMPL) + SEQ.ARRAY(PRV,SQI_MCHL)) LE 0 THEN PRV.CMP = @TRUE      ;* NO LOAD ON PRV SEQ, PREV COMP = TRUE
        IF PRV.CMP THEN
          PRV = PRV - 1 
          GOTO CMP.030 ;* PRV SEQ COMP, TRY NEXT PRV
        END ELSE
          PWC.NBR = SEQ.ARRAY(PRV,SQI_WC)
          PDEPT   = SEQ.ARRAY(PRV,SQI_DEP)
        END
      END
    END
    SEQ.IDX = I
*   
    CALL WRT.FWD.SCH(E.DATE,E.HRS,S.DATE,S.HRS,Q.DATE,Q.HRS,SHP.CAL,SEQ.IDX,MAT SEQ.ARRAY,PWC.NBR,SEQRN,ERRORS)
*
    *
    IF ERRORS # '' THEN EXCPT<-1> = ERRORS
    *
    SEQ.ARRAY(I,SQI_NSTR) = Q.DATE ;* NEW SCHEDULE START DATE (VIA SCHEDULING ROUTINES WRT.BACKWARD.SCHD)
    SEQ.ARRAY(I,SQI_NEND) = E.DATE ;* NEW SCHEDULE END DATE (VIA SCHEDULING ROUTINES WRT.BACKWARD.SCHD)

  END  ;* SEQ COMP CHECK
  *
  *
  S.DATE = E.DATE   ;* START DATE OF NEXT SEQ = END DATE OF PREV SEQ
  S.HRS = E.HRS
  *
  *
NEXT I

RETURN
END

