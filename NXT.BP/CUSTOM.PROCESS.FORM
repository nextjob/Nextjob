SUBROUTINE CUSTOM.PROCESS.FORM(REC,REC_ID,CUST_NAME,CUST_PO,ISSUE_BY,ISSUE_DATE,PRINTER.NBR,GUIERRORS,GUISTATE)
**************************************************************************
* This is free and unencumbered software released into the public domain.
*
* Anyone is free to copy, modify, publish, use, compile, sell, or
* distribute this software, either in source code form or as a compiled
* binary, for any purpose, commercial or non-commercial, and by any
* means.
*
* In jurisdictions that recognize copyright laws, the author or authors
* of this software dedicate any and all copyright interest in the
* software to the public domain. We make this dedication for the benefit
* of the public at large and to the detriment of our heirs and
* successors. We intend this dedication to be an overt act of
* relinquishment in perpetuity of all present and future rights to this
* software under copyright law.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
* IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
* OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
* OTHER DEALINGS IN THE SOFTWARE.
*
* For more information, please refer to <https://unlicense.org>
**************************************************************************
*
* MODULE: CUSTOM.PROCESS.FORM
* AUTHOR: MAB
* VERSION: 1.0.0
* CREATED: 00/00/2007
* UPDATED:
*
* MAINTENANCE RECORD:
*
* EQUATE:
*
*
* VARIABLES:
* REC -    ORDER _CHILD RECORD
* REC_ID - ORDER _CHILD RECORD ID
* CUST_NAME - CUSTOMER NAME
* CUST_PO   - CUSTOMER PO NUMBER
* ISSUE_BY  - ORDER ENTERED BY INITIALS
* ISSUE_DATE - ORDER ENTRY DATE
* PRINTER.NBR - PRINTER UNIT NUMBER TO SEND PROCESS FORM TO
*
*
* FILES:
*
*
* DESIGN DESCRIPTION:
* PRODUCES PROCESS ROUTER (CUSTOM DESIGN FOR PLATING PROCESS)
** INCLUDE STANDARD VARIABLE, EQUATES
*
$INCLUDE NXT.INCLUDES NXT.COMMON
$INCLUDE NXT.INCLUDES NXT.EQUATES
$INCLUDE NXT.INCLUDES NXT.PRT.EQUATES
$INCLUDE NXT.INCLUDES NXT.ERR.MSGS
$INCLUDE NXT.INCLUDES SYSTEM_FILE.EQU
$INCLUDE NXT.INCLUDES ORDER_CHILD.H
$INCLUDE NXT.INCLUDES ORDER_PARENT.H
$INCLUDE NXT.INCLUDES PARTS.H
$INCLUDE NXT.INCLUDES PROCESS_STEPS.H
!
GET_REC_MSG_LIST = ''
FROZEN = 0
YSHADE = ""
*
* DEFINE CHARACTER FOR "X" PRINTING IN SHADED BOXES
*
XCHAR1  = ESC:'(10U':ESC:'(s0p4h0s0b4099T'
*
* GET THE CERT CODES AND DESCRIPTIONS
* CERT.IDX = AM LIST OF CERT CODES
* CERT.LIST = VM LIST OF CERT CODE AND DESC
*             CERT.CODE:SVM:DESC:VM:CERT.CODE:SVM:DESC .......
*
CERT.LIST = ''
CERT.IDX = ''
CALL LIST.LOAD(C.VALIDATION_FILE,"CERT.DESC","2",'',CERT.LIST,CERT.IDX,LIST.COUNT,EMSG)
*
* GET THE SPC CODES AND DESCRIPTIONS
* SPC.IDX = AM LIST OF SALES CODES
* SPC.LIST = VM LIST OF SALES CODE AND DESC
*             SALES.CODE:SVM:DESC:VM:SALES.CODE:SVM:DESC .......
*
SPC.LIST = ''
SPC.IDX = ''
CALL LIST.LOAD(C.VALIDATION_FILE,"SALES.CODES","2",'',SPC.LIST,SPC.IDX,LIST.COUNT,EMSG)
*
* IF THIS IS NOT A NON STANDARD PART, GET THE PARTS RECORD
*
PART_NBR = REC<OC_PART_NBR>
IF REC<OC_NONSTD> THEN
   APPROV.BY = "NSTD"
   APPROV.REV = "N/A"
   APPROV.DATE = "N/A"
END ELSE
   CALL GET.RECORD("PARTS",C.PARTS,PART_NBR,PARTS_REC,@FALSE,ERROR_STATUS,GET_REC_MSG_LIST,GUIERRORS,GUISTATE)
   IF ERROR_STATUS = ERR_NOF OR PARTS_REC = '' THEN
      LOG.OPTS = "DISPLAY"
      ERROR_NBR = ERR_SYS
      ERROR_MSG = REC_ID:' Order child has ref to missing parts record ':PART_NBR
      CALL LOG.ERROR(LOG.OPTS,"CUSTOM.PROCESS.FORM", ERROR_NBR, ERROR_MSG, GUIERRORS, GUISTATE)
      *
      APPROV.BY = "MISSING"
      APPROV.REV = ""
      APPROV.DATE = ""
      FROZEN = 0
   END ELSE
      FROZEN = PARTS_REC<PT_FROZEN>
      APPROV.REV = DCOUNT(PARTS_REC<PT_REVCTL_INIT>,@VM)  ;* REV IS NUMBER OF ENTRIES IN REV DATA
      IF APPROV.REV > 0 THEN

         APPROV.BY = PARTS_REC<PT_REVCTL_INIT,APPROV.REV>
         IF APPROV.BY = "" THEN   ;* THERE COULD BE A BLANK ENTRY HERE, IF NO INITIALS TREAT AS N/A
            APPROV.BY = "N/A"
            APPROV.REV = "N/A"
            APPROV.DATE = "N/A"
         END ELSE
            APPROV.DATE = OCONV(PARTS_REC<PT_REVCTL_DATE,APPROV.REV>,PT_REVCTL_DATE.CNV)
         END
      END ELSE
         APPROV.BY = "N/A"
         APPROV.REV = "N/A"
         APPROV.DATE = "N/A"
      END
   END
END
*
CALL CUSTOM.PROCESS.TEMPLATE(PROFM)  ;* GET FORM TEMPLATE
FD = PROFM
*
* INIT SOME STUFF
*
PAGE.CNT = 0 ;* PAGE COUNTER
YMAX = 3000  ;* MAX DOT POSITION FOR BOTTOM OF PROCESS FORM
TOP_OF_DESC = 590 ;* Y POS FOR FIRST DESC (PROCESS STEP)
YINC = 30          ;* y INC FOR EACH SEQ DETAIL LINE
PG.TRIP = (3*YINC)+1 ;* IF WE HAVE LESS THAN THIS SPACE LEFT AT THE START OF A NEW STEP, START A NEW PAGE
OUT.DATA = ''
*
DEL_QTY = 0
DEL.CNT = DCOUNT(REC<OC_ORD_QTY>,@VM)
FOR I = 1 TO DEL.CNT
   DEL_QTY += REC<OC_ORD_QTY,I>
NEXT I
PROCESS_IDS   = REC<OC_PROCESS_ID>     ;* PULL OFF PROCESS STEP PROCES ID LIST
PROCESS_DESC = REC<OC_PROCESS_DESC>
PROCESS_CERT = REC<OC_PROCESS_CERT>
PART_DESC    = REC<OC_PART_DESC>
PART_REV     = REC<OC_REV>
PART_DRAW    = REC<OC_DRAWING>
PART_MTL     = REC<OC_MATL>
NOTES        = REC<OC_ITEM_NOTES>
DUE_DATE     = OCONV(REC<OC_DUE_DATE,1>,OC_DUE_DATE.CNV)
TEST_SAMPLES = REC<OC_TEST_SAMPLES>
*
* PULL OFF SALES PRODUCT CODE AND DESC, ADD TO ROUTER
* (NOTE DFLT = "STANDARD"
* MAB 1/12/21
*SPC_ID = REC<OC_SPC>     ;* SALES PRODUCT CODE
*IF SPC_ID = '' THEN
*SPC_DESC = "STANDARD"
*END ELSE
*LOCATE SPC_ID IN SPC.IDX<1> SETTING IDX THEN
*SPC_DESC  = SPC.LIST<1,IDX,2>
*END ELSE
*SPC_DESC  = SPC_ID:'-':"Not Found"
*END
*END
*
*FD = FD:CG15:ESC:'*p900x0Y':SPC_DESC
* PART AND REV
FD = FD:CG12
FD = FD:ESC:'*p30x170Y':FIELD(REC_ID,"*",1):'-':FIELD(REC_ID,"*",2)    ;* JOB NUMBER = ORDER NUMBER
FD = FD:ESC:'*p332x170Y':CUST_NAME"L#16"
FD = FD:ESC:'*p920x170Y':CUST_PO"L#15"
FD = FD:ESC:'*p1415x170Y':PART_NBR"L#26"
FD = FD:ESC:'*p2260x170Y':PART_REV"L#5"
*
FD = FD:CG10
FD = FD:ESC:'*p30x280Y':PART_MTL"L#16"
FD = FD:ESC:'*p560x280Y':DEL_QTY"R#9"
FD = FD:ESC:'*p920x280Y':DUE_DATE
FD = FD:ESC:'*p1305x280Y':PART_DESC "L#22"
*
FD = FD:ESC:'*p1950x280Y':ISSUE_BY "L#4"
FD = FD:ESC:'*p2195x280Y':OCONV(ISSUE_DATE,OP_DATE.CNV)
*
IF TEST_SAMPLES THEN
   FD = FD:ESC:'*p360x340Y':"Yes"
   FD = FD:ESC:'*p30x400Y':"See Description Text For Material and Qty"

END ELSE
   FD = FD:ESC:'*p360x340Y':"No"
END
*
IF FROZEN THEN
   FD = FD:ESC:'*p1400x340Y':"Yes"
END ELSE
   FD = FD:ESC:'*p1400x340Y':"No"
END
*
FD = FD:ESC:'*p1746x390Y':APPROV.BY"L#5"
FD = FD:ESC:'*p2005x390Y':APPROV.REV
FD = FD:ESC:'*p2124x390Y':APPROV.DATE
*
YPOS = TOP_OF_DESC
YOFF = 0
PROFM = FD  ;* SAVE TEMPLATE FOR EXTRA PAGES
*
* HOW MANY PROCESS STEPS
*
STEP.CNT = DCOUNT(PROCESS_IDS,@VM)
IF STEP.CNT = 0 THEN
   YPOS += YINC                ;* WE NEED THIS TO FORCE PRINTING OF PART WITH NO PROCESS SEQUENCES
END ELSE
   *
   SEQ.COUNTER = 0
   FOR SEQ = 1 TO STEP.CNT
      *
      * FORCE THE START OF A NEW PAGE IF LESS THAN 3 LINES REMAIING ON PAGE
      * REM YPOS IS ALWAYS DEFINED AS TOP_OF_DESC + YOFF
      IF (TOP_OF_DESC + YOFF) > (YMAX - PG.TRIP) THEN
         YPOS = YMAX + 1
         GOSUB PAGE.TEST
      END
      *
      PROCESS_STEP_ID = PROCESS_IDS<1,SEQ>
      *
      * INIT VAR FOR THIS SEQ
      *
      PROCEDURE = ''
      CHK.TIME  = @FALSE
      CHK.TEMP  = @FALSE
      CHK.VOLTS = @FALSE
      CHK.QTY   = @FALSE
      CHK.OPR   = @FALSE
      CHK.DATE  = @FALSE
      *

      *
      * NOTE
      * PROCESS STEPS ARE VALUE MARKED FIELDS
      * CUSTOM DESCRIPTION SVM MARKED FIELDS
      *
      * IF THIS IS A CUSTOM / NOTES  SEQ THEN THE DESC IS SAVED IN THE ORDER CHILD RECORD
      *
      IF PROCESS_STEP_ID = "CUSTOM"  OR PROCESS_STEP_ID = "NOTES" THEN
         IF PROCESS_STEP_ID = "CUSTOM" THEN SEQ.COUNTER += 1  ;* DO NOT INC COUNTER FOR NOTES THEY STAY WITH THE PREVIOUS STEP
         STEP.DESC = PROCESS_DESC<1,SEQ>
         CONVERT @SVM TO @VM IN STEP.DESC
      END ELSE
         SEQ.COUNTER += 1
         *
         * IF ITS NOT A CUSTOM / NOTES, MUST GET DESC FROM THE PROCESS STEPS RECORD
         *
         CALL GET.RECORD("PROCESS_STEPS",C.PROCESS_STEPS,PROCESS_STEP_ID,PROCESS_REC,@FALSE,ERROR_STATUS,GET_REC_MSG_LIST,GUIERRORS,GUISTATE)
         IF ERROR_STATUS = '' THEN
            STEP.DESC = PROCESS_REC<PS_PROCESS_DESC>
            CHK.TIME  = PROCESS_REC<PS_CHK_TIME>
            CHK.TEMP  = PROCESS_REC<PS_CHK_TEMP>
            CHK.VOLTS = PROCESS_REC<PS_CHK_VOLTS>
            CHK.QTY   = PROCESS_REC<PS_CHK_QTY>
            CHK.OPR   = PROCESS_REC<PS_CHK_OPR>
            CHK.DATE  = PROCESS_REC<PS_CHK_DATE>
         END ELSE
            STEP.DESC = "Process Step: ":PROCESS_STEP_ID:', Not on File?'
         END
         *
         * GET CERT DESC FOR THIS SEQ (IF ANY)
         *
         CERT.CODE = REC<OC_PROCESS_CERT_CODE,SEQ>
         IF CERT.CODE = "NONE" OR CERT.CODE = '' THEN
            CERT.DESC = ''
         END ELSE
            *
            LOCATE REC<OC_PROCESS_CERT_CODE,SEQ> IN CERT.IDX<1> SETTING IDX THEN
               CERT.DESC  = CERT.LIST<1,IDX,2>
            END ELSE
               CERT.DESC  = "Not Found"
            END
            STEP.DESC = STEP.DESC:@VM:CERT.DESC
         END
      END
      *

      *
      * PRINT THE THIS PROCESS'S PROCESS ROUTER
      *
      SEQ.LN.COUNT = DCOUNT(STEP.DESC,@VM)  ;* INDIVIDUAL LINES WITHIN EACH STEP MAKE UP A SEQ, SEPARATED BY VM

      *
      SEQ.NBR.DATA = (SEQ.COUNTER * 10)"R#4"   ;* SETUP TO PRINT SEQ NUMBER AND PROCESS_STEP_ID ON FIRST LINE OF SEQ DESC
      *
      IF PROCESS_STEP_ID = "NOTES" THEN  ;* ON NOTES WE DO NOT PRINT SEQ NUMBER
         SEQ.NBR.DATA = ''
      END

      *
      STEP_ID.DATA = PROCESS_STEP_ID   ;* POPULATE ONCE FOR SPLIT.STEP_ID
      FD := CPI.16
      *
      LINES.PRINTED = 0                              ;* 16 CPI
      IF SEQ.LN.COUNT GE 3 THEN
         LINES.TO.PRINT = SEQ.LN.COUNT
      END ELSE
         LINES.TO.PRINT = 3
      END
      *
      *
      YBOX1 = TOP_OF_DESC + YOFF   ;* SAVE STARTING Y OF DATA ENTRY BOXES (TANK TIME, RAMP TIME, MAX VOLTS, etc...)
      *
      *
      FOR SEQ.LNS = 1 TO LINES.TO.PRINT
         *
         DATA.LN = STEP.DESC<1,SEQ.LNS>           ;* PULL OFF THE PROCESS STEP SEQUENCE AND PRINT IT
         *      IF LEN(TRIM(DATA.LN)) > 0 THEN          ;* ONLY PROCESS LINES WITH TEXT
         GOSUB LN.PRINT
         SEQ.NBR.DATA = ''
         STEP_ID.TXT = ''
         *      END
      NEXT SEQ.LNS
      *
      YOFF -= YINC   ;* THIS WAS INC AT LAST LINE OUTPUT
      *
      *
      * DO WE NEED MORE ROOM FOR THE SIGNOFF BLOCK (SINGLE LINES OF DESC TEXT?)
      *
      IF LINES.PRINTED LT 4 THEN
         *//      YOFF -= YINC   ;* THIS WAS INC AT LAST LINE OUTPUT
         FOR FILLER = 1 TO 4 - LINES.PRINTED
            YOFF += YINC
            YPOS = TOP_OF_DESC + YOFF
            GOSUB SHADE.BOXES
         NEXT FILLER
         *
         * IF THE NEXT SET IS A NOTE WE DO NOT SEPARATE WITH HZ LINE
         *
         IF PROCESS_IDS<1,SEQ+1> # "NOTES" THEN
            YOFF -= YINC
            YPOS = TOP_OF_DESC + YOFF
            FD = FD:ESC:'*p0x':YPOS:'Y':ESC:'*c2395a5b0P'     ;* bottom hz line for this seq
         END
      END ELSE
         *
         * IF THE NEXT SET IS A NOTE WE DO NOT SEPARATE WITH HZ LINE
         *
         IF PROCESS_IDS<1,SEQ+1> # "NOTES" THEN
            YOFF -= YINC
            YPOS = TOP_OF_DESC + YOFF
            FD = FD:ESC:'*p0x':YPOS:'Y':ESC:'*c2395a5b0P'     ;* bottom hz line for this seq
         END
      END
      *
      * ADD "X" TO SHADED BOXES
      *
      YBOX2 = TOP_OF_DESC + YOFF
      GOSUB X.BOX
      *
      * SPACE DOWN UNDER THE LINE FOR SEQ
      *
      YOFF += YINC
      YPOS = TOP_OF_DESC + YOFF
      *
   NEXT SEQ
END
*
*
* PRINT LAST PAGE?
IF YPOS # TOP_OF_DESC THEN   ;* LAST PAGE TO PRINT ?
   PAGE.CNT += 1
   FD := ESC:'*p0x3085Y':'page: ':PAGE.CNT
   OUT.DATA = OUT.DATA : FD
   IF PRINTER.NBR > 0 THEN  ;* PDF PRINT?
      PRINT ON PRINTER.NBR OUT.DATA
      PRINTER CLOSE ON PRINTER.NBR
   END ELSE
      PDF.NAME = 'CUSTOM_TRAVELER-.PDF'
      DISPLAY.ON.CREATION = @TRUE
      CALL PCL.TO.PDF(OUT.DATA,PDF.NAME,DISPLAY.ON.CREATION,GUIERRORS,GUISTATE)
   END
END
9999
RETURN
!
PAGE.TEST: *
IF YPOS > YMAX THEN
   *
   * PRINT CURRENT PAGE
   *
   PAGE.CNT += 1
   FD := ESC:'*p0x3085Y':'page: ':PAGE.CNT
   OUT.DATA = OUT.DATA : FD
   *
   * START OVER

   FD   = PROFM
   FD := CPI.16
   YPOS = TOP_OF_DESC
   YOFF = 0
END
RETURN
!
* LN.PRINT
* MUST BREAK UP TEXT LINE TO FIT ON FORM (60 CHARACTERS MAX)
* SHOULD REALLY MAKE THIS BREAK AT SPACE CHARACTER, MAYBE IN RELEASE 1.0
!
LN.PRINT: *
DESC.MX = 46     ;* MAX 46 CHARACTERS PER LINE
DESC.TXT = DATA.LN
LN.NEXT.LINE: *
LN.LEN = LEN(DESC.TXT)
GOSUB PAGE.TEST
IF LN.LEN > DESC.MX THEN
   *
   SPLIT.MX =DESC.MX
   SPLIT.TXT = DESC.TXT
   GOSUB SPLIT.LINE
   DESC.LN = SPLIT.LN
   DESC.TXT =  SPLIT.TXT
   *
   GOSUB SPLIT.STEP_ID ;* RETURNS STEP_ID.TXT
   FD = FD:ESC:'*p30x':YPOS:'Y':SEQ.NBR.DATA:ESC:'*p186x':YPOS:'Y':STEP_ID.TXT:ESC:'*p465x':YPOS:'Y':DESC.LN"L#46"
   GOSUB SHADE.BOXES
   LINES.PRINTED += 1
   STEP_ID.TXT = ''
   SEQ.NBR.DATA = ''
   YOFF += YINC
   YPOS = TOP_OF_DESC + YOFF
   IF LEN(TRIM(DESC.TXT)) > 0 THEN GOTO LN.NEXT.LINE
END ELSE
   GOSUB SPLIT.STEP_ID ;* RETURNS STEP_ID.TXT
   FD = FD:ESC:'*p30x':YPOS:'Y':SEQ.NBR.DATA:ESC:'*p186x':YPOS:'Y':STEP_ID.TXT:ESC:'*p465x':YPOS:'Y':DESC.TXT"L#46"
   GOSUB SHADE.BOXES
   LINES.PRINTED += 1
   YOFF += YINC
   YPOS = TOP_OF_DESC + YOFF
END
RETURN
!
*
* SPLIT.LINE
* ROUTINE SPLITS LINE ON WORD BOUNDARIES
* SPLIT.MX = MAX LINE LINE LENGHT
* SPLIT.TXT = LINE TO SPLIT AT WORD WITH LINE LE SPLIT.MX LENGTH
* SPLIT.LN = RETURNED SPLIT LINE
* SPLIT.TXT = RETURNED REMAINING LINE
!
SPLIT.LINE:
SPLIT.LEN = LEN(SPLIT.TXT)
*
* WILL ALL OF TXT FIT IN SPLIT.MX WIDTH ?
IF SPLIT.LEN LE SPLIT.MX THEN
   SPLIT.LN = SPLIT.TXT
   SPLIT.TXT = ''
END ELSE
   *
   * ARE WE LUCKING ENOUGH TO HAVE SPACE AT MAX CHARACTER?
   IF SPLIT.TXT[SPLIT.MX,1] = ' ' THEN  ;* YES, SPLIT AND RETURN
      SPLIT.LN = SPLIT.TXT[1,SPLIT.MX]
      SPLIT.TXT = SPLIT.TXT[SPLIT.MX+1,SPLIT.LEN]
   END ELSE
      *
      * SPLIT LINE AT SPLIT.MX THEN SCAN FROM SPLIT.MX TO BEGINNING LOOKING FOR A SPACE
      * SPLIT AT THAT POINT
      *
      DONE = @FALSE
      SPLIT.LN = SPLIT.TXT[1,SPLIT.MX]
      SPACE.TEST.POS = LEN(SPLIT.LN)
      FOR SP = SPACE.TEST.POS TO 1 STEP -1 UNTIL DONE
         IF SPLIT.LN[SP,1] = ' ' THEN
            SPLIT.LN = SPLIT.LN[1,SP]
            SPLIT.TXT = SPLIT.TXT[SP+1, SPLIT.LEN]
            DONE = @TRUE
         END
      NEXT SP
      *
      * DID WE FIND A SPACE ?
      *
      IF NOT(DONE) THEN
         * NO, SPLIT AT SPLIT.MX
         SPLIT.LN = SPLIT.TXT[1,SPLIT.MX]
         SPLIT.TXT = SPLIT.TXT[SPLIT.MX+1,SPLIT.LEN]
      END
   END
END
RETURN
!
* SPLIT.STEP_ID ;* RETURNS STEP_ID.TXT
* CALLED TO POPULATE STEP_ID.TXT FROM STEP_ID.DATA
* ROUTINE SPLITS OFF CHUNKS OF TEXT FROM STEP.ID_DATA AND POPULATES
* STEP_ID.TXT WITH IT, ONCE ALL TEXT SPLIT OUT, RETURNS NULL
!
SPLIT.STEP_ID:
* SPLIT.MX = MAX LINE LINE LENGHT
* SPLIT.TXT = LINE TO SPLIT AT WORD WITH LINE LE SPLIT.MX LENGTH
SPLIT.MX = 14
SPLIT.TXT = STEP_ID.DATA
GOSUB SPLIT.LINE
* SPLIT.LN = RETURNED SPLIT LINE
* SPLIT.TXT = RETURNED REMAINING LINE
STEP_ID.TXT = SPLIT.LN
STEP_ID.DATA = SPLIT.TXT
RETURN
!
* SHADE.BOXES
* CALLS FOR SHADING LINES BASED ON CHK.* SETTINGS
!
SHADE.BOXES:
*YSHADE = YPOS - YINC
*IF NOT(CHK.TIME) THEN GOSUB SHADE.TIME
*IF NOT(CHK.TEMP) THEN GOSUB SHADE.TEMP
*IF NOT(CHK.VOLTS) THEN GOSUB SHADE.VOLTS
*IF NOT(CHK.QTY) THEN GOSUB SHADE.QTY
*IF NOT(CHK.OPR) THEN GOSUB SHADE.OPR
*IF NOT(CHK.DATE) THEN GOSUB SHADE.DATE
RETURN
!
* SHADE.TIME
* YPOS = Y POSITION OF TEXT LINE THAT NEEDS SHADING (MAY NEED TO OFFSET FOR SHADE BOX)
!
SHADE.TIME:
FD = FD:ESC:'*p1345x':YSHADE:'Y':ESC:'*c150a35b20g2P'    ;* shade this line
RETURN
!
* SHADE.TEMP
* YSHADE = Y POSITION OF TEXT LINE THAT NEEDS SHADING (MAY NEED TO OFFSET FOR SHADE BOX)
!
SHADE.TEMP:
FD = FD:ESC:'*p1495x':YSHADE:'Y':ESC:'*c150a35b20g2P'    ;* shade this line
RETURN
!
* SHADE.VOLTS
* YSHADE = Y POSITION OF TEXT LINE THAT NEEDS SHADING (MAY NEED TO OFFSET FOR SHADE BOX)
!
SHADE.VOLTS:
FD = FD:ESC:'*p1645x':YSHADE:'Y':ESC:'*c150a35b20g2P'    ;* shade this line
RETURN
!
* SHADE.QTY
* YSHADE = Y POSITION OF TEXT LINE THAT NEEDS SHADING (MAY NEED TO OFFSET FOR SHADE BOX)
!
SHADE.QTY:
FD = FD:ESC:'*p1795x':YSHADE:'Y':ESC:'*c150a35b20g2P'    ;* shade this line
RETURN
!
* SHADE.OPR
* YSHADE = Y POSITION OF TEXT LINE THAT NEEDS SHADING (MAY NEED TO OFFSET FOR SHADE BOX)
!
SHADE.OPR:
FD = FD:ESC:'*p1945x':YSHADE:'Y':ESC:'*c235a35b20g2P'    ;* shade this line
RETURN
!
* SHADE.DATE
* YSHADE = Y POSITION OF TEXT LINE THAT NEEDS SHADING (MAY NEED TO OFFSET FOR SHADE BOX)
!
SHADE.DATE:
FD = FD:ESC:'*p2182x':YSHADE:'Y':ESC:'*c210a35b20g2P'    ;* shade this line
RETURN
!
* X.BOX
* ADD X TO SHADED BOXES
!
X.BOX:
YLOC = YBOX2 - (INT((YBOX2 - YBOX1)/2)) + 10
IF NOT(CHK.TIME) THEN GOSUB X.TIME
IF NOT(CHK.TEMP) THEN GOSUB X.TEMP
IF NOT(CHK.VOLTS) THEN GOSUB X.VOLTS
IF NOT(CHK.QTY) THEN GOSUB X.QTY
IF NOT(CHK.OPR) THEN GOSUB X.OPR
IF NOT(CHK.DATE) THEN GOSUB X.DATE
RETURN
!
* X.TIME
* YHGT =  Y HEIGHT OF X
* YBOX2 = Y POSITION OF BOTTOM OF BOX TO MARK WITH X
!
X.TIME:
FD = FD:ESC:'*p1375x':YLOC:'Y':XCHAR1:'x':CPI.16
RETURN
!
* X.TEMP
* YHGT =  Y HEIGHT OF X
* YBOX2 = Y POSITION OF BOTTOM OF BOX TO MARK WITH X
!
X.TEMP:
FD = FD:ESC:'*p1525x':YLOC:'Y':XCHAR1:'x':CPI.16
RETURN
!
* X.VOLTS
* YHGT =  Y HEIGHT OF X
* YBOX2 = Y POSITION OF BOTTOM OF BOX TO MARK WITH X
!
X.VOLTS:
FD = FD:ESC:'*p1675x':YLOC:'Y':XCHAR1:'x':CPI.16
RETURN
!
* X.QTY
* YHGT =  Y HEIGHT OF X
* YBOX2 = Y POSITION OF BOTTOM OF BOX TO MARK WITH X
!
X.QTY:
FD = FD:ESC:'*p1825x':YLOC:'Y':XCHAR1:'x':CPI.16
RETURN
!
* X.OPR
* YHGT =  Y HEIGHT OF X
* YBOX2 = Y POSITION OF BOTTOM OF BOX TO MARK WITH X
!
X.OPR:
FD = FD:ESC:'*p2020x':YLOC:'Y':XCHAR1:'x':CPI.16
RETURN
!
* X.DATE
* YHGT =  Y HEIGHT OF X
* YBOX2 = Y POSITION OF BOTTOM OF BOX TO MARK WITH X
!
X.DATE:
FD = FD:ESC:'*p2235x':YLOC:'Y':XCHAR1:'x':CPI.16
RETURN
END

