SUBROUTINE WRT.BKW.SCH (E.DATE,EU.HRS,S.DATE,SU.HRS,Q.DATE,QU.HRS,SHP.CAL,SEQ.IDX,MAT SEQ.ARRAY,WC.P,SEQ.RN,ERRORS)
!
**************************************************************************
* This is free and unencumbered software released into the public domain.
*
* Anyone is free to copy, modify, publish, use, compile, sell, or
* distribute this software, either in source code form or as a compiled
* binary, for any purpose, commercial or non-commercial, and by any
* means.
*
* In jurisdictions that recognize copyright laws, the author or authors
* of this software dedicate any and all copyright interest in the
* software to the public domain. We make this dedication for the benefit
* of the public at large and to the detriment of our heirs and
* successors. We intend this dedication to be an overt act of
* relinquishment in perpetuity of all present and future rights to this
* software under copyright law.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
* IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
* OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
* OTHER DEALINGS IN THE SOFTWARE.
*
* For more information, please refer to <https://unlicense.org>
**************************************************************************
*
* MODULE: WRT.BKW.SCH
* AUTHOR: MAB
* VERSION: 1.0.0
* CREATED: 03/01/2014
* UPDATED:
*
* MAINTENANCE RECORD:
*
* EQUATE:
*
*
* VARIABLES:
* ROUTINE BKW SCHEDULES SEQ ENDING DATES
* VARIABLES:
* ON ENTRY:
* E.DATE    - DUE DATE OF SEQ
* EU.HRS    - HOURS LOADED ONTO E.DATE

* SHP.CAL   - SHOP CALENDAR RECORD
* SEQ.IDX   - INDEX INTO SEQ.ARRAY FOR SEQ BEING SCHEDULED
* SEQ.ARRAY - 2 DIM ARRAY CONTAINING SEQ DATA IN ROWS SEE NXT.EQUATES FOR LAYOUT
*           - POPULATED VIA WO.GRDRT.UPDATE
* WC.P      - PREVIOUS  WC (FROM PRE SEQ)
* SEQ.RN    - SEQ RUNNING (NOT Q OR NS)
*
* ON EXIT
* S.DATE    - SCHD START DATE OF SEQ
* SU.HRS    - HOURS OF LOAD PLACED ON S.DATE
* Q.DATE    - SCHD START DATE OF Q&M
* QU.HRS    - HRS ALREADY LOADED ON Q.DATE
*
* DESIGN DESCRIPTION:
* CHECK ENDING DATE FOR holiday, DEC DATE IF SO
* CHECK ENDING DATE FOR WORK CENTER AVAILABLE
* CALCULATE QUEUE AND MOVE TIME
* BKW SCH OUT Q AND M
* BKW SCH OUT LOAD HOURS
* RETURN
*
***************************************************************************
** INCLUDE STANDARD VARIABLE, EQUATES
*
*
$INCLUDE NXT.INCLUDES NXT.COMMON
$INCLUDE NXT.INCLUDES NXT.EQUATES
$INCLUDE NXT.INCLUDES WC_LOAD.H
**
PGM.NAME = "WRT.BKW.SCH"
*
DIM SEQ.ARRAY(1,1)  ;* DUMMY DECLARATION OF SEQ INFO ARRAY*
*
S.DATE = E.DATE
SU.HRS = EU.HRS
Q.DATE = E.DATE
QU.HRS = EU.HRS
QM.HRS = 0    ;* TOTAL QUEUE AND MOVE HRS
ERRORS = ''
MAX.SANITY.CHECK = 3650            ;* MAX NUMBER OF TIMES WE ARE GOING TO ALLOW THE SCHEDULER TO CYCLE THRU DATES
SANITY.CHECK = 0
*
* PULL DATA OUT OF SEQ.ARRAY FOR THIS SEQ
*
WC.C     = SEQ.ARRAY(SEQ.IDX,SQI_WC)
SCH.MON  = SEQ.ARRAY(SEQ.IDX,SQI_MON)
WC.Q     = SEQ.ARRAY(SEQ.IDX,SQI_QUE)
WC.M     = SEQ.ARRAY(SEQ.IDX,SQI_MOV)
EMP.LOAD.HRS  = SEQ.ARRAY(SEQ.IDX,SQI_EMPL)
MACH.LOAD.HRS  = SEQ.ARRAY(SEQ.IDX,SQI_MCHL)
*
* DEBUG
*CRT "-------------------------------------------------"
*CRT "WC.C: ":WC.C
*CRT "SCH.MON: ":SCH.MON
*CRT "WC.Q: ":WC.Q
*CRT "WC.M: ":WC.M
*CRT "EMP.LOAD.HRS: ":EMP.LOAD.HRS
*CRT "MACH.LOAD.HRS: ":MACH.LOAD.HRS
**
** debug data
*E_REC = ''
*E_REC<1> =  "SEQ - On Entry: "   : SEQ.ARRAY(SEQ.IDX,SQI_ID)
*E_REC<2> = "E.DATE:" : OCONV(E.DATE,"D2/")
*E_REC<3> = "EU.HRS:" : EU.HRS

*
*
* DOES THIS WORK CENTER HAVE A VALID SCHEDULE?
* (IE THERE ARE DAYS WITH AVAILABLE HOURS DEFINE ON THE WORK CENTER RECORD)
*
HOURS.AVAILABLE = 0
FOR I = 0 TO 6
   HOURS.AVAILABLE += SEQ.ARRAY(SEQ.IDX,SQI_MON+I)
NEXT I
IF HOURS.AVAILABLE LE 0 THEN
   ERRORS = 'Warning WC: ' : WC.C :' Has no Available hours, cannot schedule Seq: ' : SEQ.ARRAY(SEQ.IDX,SQI_ID)
   GOTO 9999
END
*
* CHECK TO SEE IF PLANNED START DATE IS A HOLIDAY
*
BKW010: *
*
** DEBUG
*CRT "BKW010: S.DATE: ":OCONV(S.DATE,"D2/")
*
*
IF SANITY.CHECK > MAX.SANITY.CHECK THEN
   ERRORS = 'Warning Exceeded Sanity Check 1 cannot schedule Seq: ' : SEQ.ARRAY(SEQ.IDX,SQI_ID)
   GOTO 9999
END
LOCATE(S.DATE,SHP.CAL,1;IDX;'AR') THEN
   S.DATE = S.DATE - 1
   GOTO BKW010
END
*
* CHECK TO SEE IF WORK CENTER AVAILABLE FOR THIS DAY OF THE WEEK
*
DAYOFWEEK = OCONV(S.DATE,'DW')  ;* RETURNS 1 = MONDAY 2 = TUESDAY .. 7 = SUNDAY
DAYOFWEEK = DAYOFWEEK - 1 + SQI_MON      ;* CREATE POINTER INTO SEQ.ARRAY FOR WORK CENTER HOURS / DAY AVAILABILITY
*
WC.CAP = SEQ.ARRAY(SEQ.IDX,DAYOFWEEK) ;* HOURS WC AVAIALABLE FOR THIS DATE
*
** DEBUG
*CRT "WC.CAP: ":WC.CAP
*
IF WC.CAP LE 0 THEN
   S.DATE = S.DATE - 1
   SANITY.CHECK += 1
   GOTO BKW010
END
*
IF E.DATE # S.DATE THEN    ;* WE ENDED UP MOVING THE DATE WE START BACK LOADING ON (EITHER A HOLIDAY OR WC NOT AVAILABLE)
   SU.HRS = 0      ;* RESET USED HRS
   E.DATE = S.DATE ;* AND THE SCHEDULE END DATE WILL BE THE DATE WE START BACK SCHEDULING WITH
END
*
*
* SCHD RN HRS
*
REM.HRS = WC.CAP - SU.HRS   ;* REM HRS = WC.CAP FOR THIS DAY LESS THE HOURS WE HAVE ALREADY APPLIED ON THE LAST LOOP THRU
IF REM.HRS < 0 THEN         ;* HAVE ALREADY USED UP THE HOURS AVAIALBLE FOR THE DATE WE WHERE GOING TO END ON,
   S.DATE = S.DATE - 1       ;* YES, NO HOURS AVAIALABLE MUST START ON THE PREV DATE
   GOTO BKW010               ;* AND CHECK TO SEE IF IT IS A VALID WORK DAY
END
*
* NOW DEFINE LOAD HOURS
* NOTE WE MAY HAVE LOADING FOR BOTH EMPLOYEE AND MACHINE
* WE SCHEDULE BASED ON THE CONCURRNET SCHEDULE SETTINGS FOR THE ROUTING SEQUENCE
*
IF SEQ.ARRAY(SEQ.IDX,SQI_CCS) THEN
   *
   * SET TO CONCURRENT SCHEDULE, SCHEDULE OUT WHATEVER WILL TAKE THE MOST TIME
   *
   IF EMP.LOAD.HRS > MACH.LOAD.HRS THEN
      LOAD.HRS = EMP.LOAD.HRS
   END ELSE
      LOAD.HRS = MACH.LOAD.HRS
   END
END ELSE
   *
   * NOT CONCURRENT, SCHEDULE THEM ALL
   *
   LOAD.HRS = EMP.LOAD.HRS + MACH.LOAD.HRS
END
*
*
BEGIN CASE
   CASE LOAD.HRS LE 0        ;* NO LOAD
      NULL
      *
   CASE REM.HRS GE LOAD.HRS  ;* MORE HRS AVAIL ON DATE THEN LOAD
      SU.HRS = SU.HRS + LOAD.HRS   ;* USE THEM UP
      WCL.DATE = S.DATE
      WCL.HRS = LOAD.HRS
      GOSUB WRITE.LOAD.REC
      *
   CASE 1
      HRS = LOAD.HRS - REM.HRS     ;* USE UP HRS AVAIL TODAY
      WCL.DATE = S.DATE
      WCL.HRS = REM.HRS
      GOSUB WRITE.LOAD.REC
      C.DATE = S.DATE - 1          ;* START ON NEXT DATE
*
      LOADING.LOAD = @TRUE
      GOSUB LOAD.IT
      *
      SU.HRS = HRS                  ;* USED HRS
      S.DATE = C.DATE               ;* FOR LAST DATE LOADED
      *
END CASE
*
Q.DATE = S.DATE
QU.HRS = SU.HRS
REM.HRS = WC.CAP - QU.HRS    ;* REM HRS AVAIL ON DATE
IF REM.HRS < 0 THEN REM.HRS = 0
*
* CALC Q&M TIMES
*
IF WC.C # WC.P  THEN     ;* WC MOVE
   QM.HRS = WC.M
END
*
QM.HRS = QM.HRS + WC.Q   ;* ADD IN WC QUEUE

*
* SCHD OUT Q&M HOURS
*
BEGIN CASE
   CASE QM.HRS LE 0    ;* NO Q&M
      NULL
      *
   CASE REM.HRS GE QM.HRS    ;* MORE HRS AVAIL ON DATE THEN Q&M
      QU.HRS = QU.HRS + QM.HRS  ;* SO USE THEM UP
      *
   CASE 1                    ;* MORE Q&M THEN HRS AVIAL ON DATE
      HRS = QM.HRS - REM.HRS    ;* BURN UP HRS ON DATE
      C.DATE = Q.DATE - 1       ;* AND LOAD NEXT DATE(S)
      LOADING.LOAD = @FALSE
      GOSUB LOAD.IT
      *
      QU.HRS = HRS              ;* HRS USED (LOADED) ON
      Q.DATE = C.DATE           ;* LAST DATE LOADED
END CASE
** more DEBUG DATA
*E_REC<4> =  "SEQ-On Exit: "   : SEQ.ARRAY(SEQ.IDX,SQI_ID)
*E_REC<5> = "E.DATE:" : OCONV(E.DATE,"D2/")
*E_REC<6> = "EU.HRS:" : EU.HRS
*E_REC<7> = "S.DATE:" : OCONV(S.DATE,"D2/")
*E_REC<8> = "SU.HRS:" : SU.HRS
*E_REC<9> = "Q.DATE:" : OCONV(Q.DATE,"D2/")
*E_REC<10> = "QU.HRS:" : QU.HRS
*ERR.LOG.ID = PGM.NAME:'-':SEQ.ARRAY(SEQ.IDX,SQI_ID)
*CALL LOG.RECORD("",ERR.LOG.ID, E_REC, GUIERRORS, GUISTATE)


9999: *
RETURN
!
* LOAD.IT
* ROUTINE DISTIBUTES LOAD OVER DAYS
* ENTRY:
* C.DATE   - STRT DATE TO LOAD
* WC.CAP   - HRS CAP/DAY
* HRS      - HRS OF LOAD
* EXIT:
* C.DATE   - LST DATE LOADED
* HRS      - HRS LOADED
!
LOAD.IT: *
*
LOOP UNTIL HRS LE 0 DO
   *
   * FIRST CHECK FOR HOLIDAY (NON WORK DAY)
   *
LT010: *
   IF SANITY.CHECK > MAX.SANITY.CHECK THEN
      ERRORS = 'Warning Exceeded Sanity Check 2 cannot schedule Seq: ' : SEQ.ARRAY(SEQ.IDX,SQI_ID)
      GOTO LT99
   END
   LOCATE(C.DATE,SHP.CAL,1;IDX;'AR') THEN
      C.DATE = C.DATE - 1
      GOTO LT010
   END
   *
   * CHECK TO SEE IF WORK CENTER AVAILABLE FOR THIS DAY OF THE WEEK
   *
   DAYOFWEEK = OCONV(C.DATE,'DW')  ;* RETURNS 1 = MONDAY 2 = TUESDAY .. 7 = SUNDAY
   DAYOFWEEK = DAYOFWEEK - 1 + SQI_MON      ;* CREATE POINTER INTO SEQ.ARRAY FOR WORK CENTER HOURS / DAY AVAILABILITY
   *
   WC.CAP = SEQ.ARRAY(SEQ.IDX,DAYOFWEEK) ;* HOURS WC AVAIALABLE FOR THIS DATE
   IF WC.CAP LE 0 THEN
      C.DATE = C.DATE - 1
      SANITY.CHECK += 1
      GOTO LT010
   END
   *
   *
   REM.HRS = HRS - WC.CAP      ;* HRS TO APPLY
   IF REM.HRS > 0 THEN          ;* NEED FULL DAY
      USED.HRS = WC.CAP           ;* YES
   END ELSE
      USED.HRS = HRS               ;* NO ONLY REM
   END
   *
   IF LOADING.LOAD THEN
      WCL.DATE = C.DATE
      WCL.HRS = USED.HRS
      GOSUB WRITE.LOAD.REC
   END

   *
   C.DATE = C.DATE - 1          ;* NEXT DATE
   HRS = REM.HRS                ;* HRS LEFT
   *
REPEAT
*
C.DATE = C.DATE + 1  ;* LAST DATE LOADED
HRS = USED.HRS       ;* HRS LOADED ON DATE
*
LT99: *
RETURN
!
* CREATE WCL RECORD
!
WRITE.LOAD.REC: *
WCL_REC = ''
WCL_REC<WCL_LOAD_HRS> = ICONV(WCL.HRS,WCL_LOAD_HRS.CNV)
WCL_REC<WCL_RUN_DATE> = DATE()
WCL_ID = WCL.DATE:'*':SEQ.ARRAY(SEQ.IDX,SQI_WOID):'*':SEQ.ARRAY(SEQ.IDX,SQI_ID)
CALL WRITE.RECORD(WCL_ID,WCL_REC,C.WC_LOAD,@FALSE,ERROR_STATUS)
RETURN
*
END
