SUBROUTINE WRT.SET.STATUS(WO_ID,WR_ID,WR_REC,WR_WO_ID,WR_ID_LIST,STATUS_CODE,STATUS_DATE,UPDATE.WR.OK,GUIERRORS,GUISTATE)
!
**************************************************************************
* This is free and unencumbered software released into the public domain.
*
* Anyone is free to copy, modify, publish, use, compile, sell, or
* distribute this software, either in source code form or as a compiled
* binary, for any purpose, commercial or non-commercial, and by any
* means.
*
* In jurisdictions that recognize copyright laws, the author or authors
* of this software dedicate any and all copyright interest in the
* software to the public domain. We make this dedication for the benefit
* of the public at large and to the detriment of our heirs and
* successors. We intend this dedication to be an overt act of
* relinquishment in perpetuity of all present and future rights to this
* software under copyright law.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
* IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
* OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
* OTHER DEALINGS IN THE SOFTWARE.
*
* For more information, please refer to <https://unlicense.org>
**************************************************************************
*
* MODULE:  WRT.SET.STATUS
* AUTHOR: MAB
* VERSION: 1.0.0
* CREATED: 06/17/2015
* UPDATED:
*
* MAINTENANCE RECORD:
*
* EQUATE:
*
*
* VARIABLES:
* WO_ID - WORK ORDER ID
* WR_ID - WORK ORDER ROUTING RECORD ID
* WR_REC - WORK ORDER ROUTING RECORD (ASSUMED LOCKED BY CALLER) / ROUTINE WILL WRITE AND UNLOCK
* WR_WO_ID - WORK ORDER ID OF WORK ORDER ROUTING RECORD IDS IN WR_ID_LIST
* WR_ID_LIST - WORK ORDER ROUTING RECORD IDS LIST (CACHED BY CALLER, SEE BELOW)
* STATUS_CODE - STATUS CODE TO SET
* STATUS_DATE - DATE OF STATUS CODE
* UPDATE.WR.OK<1> - t/f
* UPDATE.WR.OK<2> - optional text message
*
* DESIGN DESCRIPTION:
*
* ROUTINE SETS OPERATION STATUS CODE ON WR_REC, THEN CHECKS TO SEE IF OPERATION STATUS CODE NEEDS TO BE
* UPDATED ON SEQUENTIAL WR_REC (IE IF STATUS_CODE IS COMPLETE, DO WE NEED TO SET THE NEXT RECORD TO QUEUE)
* NOTE- ROUTINE PASSES BACK WR_WO_ID / WR_ID_LIST BACK TO CALLER, THE ASSUMPTION BEING THAT WR RECORDS MAY BE
* PROCESSED IN SORTED ORDER, PREVENTING THE NEED TO GENTERATE A LIST OF WR RECORD IDS ON EACH CALL TO THIS ROUTINE.
* THIS MEANS THE CALLER MUST MAINTAIN THE LIST!
*
!
** INCLUDE STANDARD VARIABLE, EQUATES
*
$INCLUDE NXT.INCLUDES NXT.COMMON
$INCLUDE NXT.INCLUDES NXT.EQUATES
$INCLUDE NXT.INCLUDES NXT.WO.STATUS.DEF
$INCLUDE NXT.INCLUDES LABOR_TICKETS.H
$INCLUDE NXT.INCLUDES WRT.H
**
PGM.NAME = "WRT.SET.STATUS"
MSG_LIST = ''
*
*
* GET THE SEQ STATUS CODES
*
NS =  WORK.ORDER.SEQ.STATUS.LIST<1,WO.NS.IDX,1>
QU =  WORK.ORDER.SEQ.STATUS.LIST<1,WO.Q.IDX,1>
SU =  WORK.ORDER.SEQ.STATUS.LIST<1,WO.SU.IDX,1>
SC =  WORK.ORDER.SEQ.STATUS.LIST<1,WO.SC.IDX,1>
RN =  WORK.ORDER.SEQ.STATUS.LIST<1,WO.RN.IDX,1>
CMP = WORK.ORDER.SEQ.STATUS.LIST<1,WO.C.IDX,1>
RJT =   WORK.ORDER.SEQ.STATUS.LIST<1,WO.RJ.IDX,1>
*
STATUS_ORDER = NS:@AM:QU:@AM:SU:@AM:SC:@AM:RN:@AM:CMP  ;* ORDER IN WHICH STATUS CODES CAN CHANGE
*
CURRENT_STATUS = WR_REC<WR_STATUS>   ;* CURRENT STATUS
*
* SET ORDER OF STATUS CODE PASSED
LOCATE STATUS_CODE IN STATUS_ORDER<1> SETTING IDX THEN
   NEW.STATUS.ORDER = IDX
END ELSE
   UPDATE.WR.OK = @FALSE
   UPDATE.WR.OK<2> = "Inavalid Status Code Passed ":STATUS_CODE:' ':WR_ID
   GOTO ERR.999
END
* SET CURRENT STATUS
LOCATE CURRENT_STATUS IN STATUS_ORDER<1> SETTING IDX THEN
   CURR.STATUS.ORDER = IDX
END ELSE
   UPDATE.WR.OK = @FALSE
   UPDATE.WR.OK<2> = "Invalid Status Code On ":WR_ID:' ':CURRENT_STATUS
   GOTO ERR.999
END
*
UPDATE.WR.OK = @TRUE ;* WE WILL START OUT ASSUMING THIS IS GOING TO WORK
*
* FIRST SET STATUS FOR THIS ROUTING RECORD AND WRITE IT
*
* FIRST CHECK FOR START DATE SET
*
BEGIN CASE
   CASE WR_REC<WR_ACT_START> = ''           ;* NOT STARTED, USE THIS LAB TICKET DATE
      WR_REC<WR_ACT_START> = STATUS_DATE
   CASE WR_REC<WR_ACT_START> < STATUS_DATE  ;* TICKET EARLIER THEN WHAT IS SET, USE IT
      WR_REC<WR_ACT_START> = STATUS_DATE
END CASE
*
* THEN SET STATUS CODE
*
BEGIN CASE
      *
   CASE STATUS_CODE = RJT
      * ALWAYS ALLOW SETTING OF REJECT STATUS
      WR_REC<WR_STATUS> = STATUS_CODE
      WR_REC<WR_STAT_DATE> = STATUS_DATE
      *
   CASE STATUS_CODE # NS AND (CURRENT_STATUS = QU OR CURRENT_STATUS = NS)
      * SEQ HAS NOT STARTED, SET NEW STATUS CODE AND UPDATE STATUS DATE
      WR_REC<WR_STATUS> = STATUS_CODE
      WR_REC<WR_STAT_DATE> = STATUS_DATE
      *
   CASE NEW.STATUS.ORDER > CURR.STATUS.ORDER
      * NEW STATUS CODE IS HIGHER IN STATUS CODE ORDER, UPDATE
      WR_REC<WR_STATUS> = STATUS_CODE
      WR_REC<WR_STAT_DATE> = STATUS_DATE
END CASE
*
* FINALLY ENDING DATE
*
IF STATUS_CODE = CMP THEN
   IF  WR_REC<WR_ACT_END> + 0 < STATUS_DATE THEN  ;* USE LATEST LABOR TICKET DATE WITH STATUS CODE OF COMPLETE
      WR_REC<WR_ACT_END> = STATUS_DATE
   END
END
*
* UPDATE THE RECORD
*
CALL WRITE.RECORD(WR_ID,WR_REC,C.WR,@FALSE,ERROR_STATUS)
*
* NOW CHECK TO SEE IF STATUS CODE RESULTS IN UPDATE OF STATUS OF NEXT RECORD
*
IF STATUS_CODE = CMP THEN
   *
   * GET THE LIST OF ROUTING IDS
   * IS THIS FOR A NEW WORK ORDER ID?
   *
   IF WO_ID # WR_WO_ID THEN
      * YES, MUST GET NEW LIST
      WR_WO_ID = WO_ID
      WR_ID_LIST = ''
      SLIST = 'SSELECT WR BY WR_WONBR BY WR_SEQNBR WITH WR_WONBR = "':WR_WO_ID:'" TO 2'
      EXECUTE SLIST CAPTURING DMMY.OUT
      *
      IF @SELECTED GE 1 THEN
         *
         READLIST WR_ID_LIST FROM 2 THEN
            LIST.CT = DCOUNT(WR_ID_LIST,@AM)
         END
      END ELSE
         * WHAT TO DO IF WE CANNOT FIND THE ROUTING?
         UPDATE.WR.OK = @TRUE
         UPDATE.WR.OK<2> = "Unable to locate WR Record Ids for: ":WR_WO_ID
         WR_WO_ID = ""
         WR_ID_LIST = ''
         GOTO ERR.999
      END
   END ELSE
      LIST.CT = DCOUNT(WR_ID_LIST,@AM)  ;* USER PASSED CACHED WR_ID_LIST, HOW MANY ITEMS?
   END
   * WE  HAVE THE WR IDS IN WR_ID_LIST
   * FIND WHERE TO START (SEQUENCE AFTER THE ONE WE JUST MARKED COMPLETE)
   *
   LOCATE WR_ID IN WR_ID_LIST<1> SETTING IDX THEN
      IDX += 1  ;* POINT TO NEXT SEQ IN LIST
      FOR I = IDX TO LIST.CT
         NWR_ID = WR_ID_LIST<I>
         CALL NXT.LOCKWAITING("WR",C.WR,NWR_ID,GUIERRORS,GUISTATE)
         CALL GET.RECORD("WR",C.WR,NWR_ID,NWR_REC,@FALSE,ERROR_STATUS,MSG_LIST,GUIERRORS,GUISTATE)
         *
         * CHECK STATUS
         BEGIN CASE
            CASE  NWR_REC<WR_STATUS> = CMP
               *
               * NEXT SEQ IS MARKED COMPLETE, WE NEED TO CHECK THE NEXT SEQ IN THE LIST
               RELEASE C.FILE.VAR(C.WR), NWR_ID
            CASE  NWR_REC<WR_STATUS> = NS
               *
               * NEXT SEQ STATUS IS NOT STARTED, MARK AS IN QUEUE AND EXIT LOOP
               NWR_REC<WR_STATUS> = QU
               NWR_REC<WR_STAT_DATE> = DATE()
               CALL WRITE.RECORD(NWR_ID,NWR_REC,C.WR,@FALSE,ERROR_STATUS)
               EXIT
            CASE 1
               *
               * NEXT SEQ IN LIST IS NOT IN A NOT STARTED STATE AND NOT COMPLETE, WE DO NOT NEED
               * TO GO ANY FURTHER
               RELEASE C.FILE.VAR(C.WR), NWR_ID
               EXIT
         END CASE
      NEXT I
   END ELSE
      UPDATE.WR.OK = @TRUE
      XWR_ID_LIST = WR_ID_LIST
      CONVERT @AM TO ',' IN XWR_ID_LIST
      UPDATE.WR.OK<2> = "Unable to locate WR Id in WR Id List: ":WR_ID:' ':XWR_ID_LIST
      WR_WO_ID = ""
      WR_ID_LIST = ''
      GOTO ERR.999
   END

END
ERR.999: *
RETURN
END

