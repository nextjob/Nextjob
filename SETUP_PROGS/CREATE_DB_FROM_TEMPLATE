*
* PROGRAM CREATES  A DATA BASE FROM A PREVIOUSLY CREATED INSTALL TEMPLATE FILE
*
*  HOW I ENVISION THIS WORKING:
*
*  USER DOWNLOADS APPLICTION FILES FROM GITHUB TO TEMP DIRECTORY
*
*  USER CREATES QMACCOUNTS DIRECTORY VIA WINDOWS OS  IE) C:\QMACCOUNTS
*
*  USER INSTALLS QM
*    FROM QM CONSOLE PROGRAM:
*
*       USER CREATES ACCUTERM ACCOUNT EQ) CREATE-ACCOUNT ACCUTERM C:\QMACCOUNTS\ACCUTERM
*       USER CREATES NEXTJOB ACCOUNT  EQ) CREATE-ACCOUNT NEXTJOB C:\QMACCOUNTS\NEXTJOB
*
*  USER INSTALLS  AND SETS UP ACCUTERM SOFTWARE
*  USER INSTALLS ACCUTERM HOST PROGRAMS ON SERVER INTO ACCUTERM ACCOUNT (ACCUTERM MENU -> MULTIVALUE -> HOST PROGRAMS -> INSTALL)
*  USER UPDATES NEXTJOB ACCOUNT WITH ACCUTERM HOST PROGRAMS (ACCUTERM MENU -> MULTIVALUE -> HOST PROGRAMS -> ACCOUNT SETUP)
*
*  USER LOGS INTO NEXTJOB ACCOUNT VIA ACCUTERM
*  AT COMMAND PROMPT:
*   pterm case noinvert  <-- THIS IS VERY IMPORTANT, OTHERWISE QM WILL AUTOMATICALLY INVER CASE AT INPUT LINE AN REALLLY SCREW THINGS UP!
*   CREATE-FILE NXT.BP DIRECTORY
*   CREATE-FILE NXT.INCLUDES DIRECTORY
*   CREATE-FILE NXT.FORMS  DIRECTORY
*   CREATE-FILE SETUP_PROGS DIRECTORY
*   CREATE-FILE SETUP_DATA DIRECTORY
*
*  User creates the following VOC file entry: Consult the QM manual for each lines meaning.
*  The SETPTR command shown here is an example, user will need to provide the correct printer settings for their environment.
*-----------------------------------------------------------------------------------------------------------------------------------
*  PA
*  TERM VT100-AT
*  pterm case noinvert
*  IF @TTY = 'vbsrvr' THEN STOP
*
*  SETPTR 0,128,66,3,3,1,AT "HP_Printer", PCL, CPI 16, PAPER.SIZE LETTER, BRIEF
*  IF @SYSTEM.RETURN.CODE < 0 THEN NXT.MSG.BOX /NextJob/Print Unit 0 Not Assigned "HP1518 "/0
*
*-----------------------------------------------------------------------------------------------------------------------------------
*
*   FROM INSTALL DOWNLOAD TO TEMP DIRECTORY AND USE WINDOWS OS TO:
*         COPY SETUP_PROGS TO C:\QMACCOUNTS\NEXTJOB\SETUP_PROGS
*         COPY SETUP_DATA TO  C:\QMACCOUNTS\NEXTJOB\SETUP_DATA
*         COPY NXT.BP TO C:\QMACCOUNTS\NEXTJOB\NXT.BP
*         COPY NXT.FORMS TO C:\QMACCOUNTS\NEXTJOB\NXT.FORMS
*
*   FROM ACCUTERM, QM COMMAND PROMPT
*      BASIC SETUP_PROGS *
*      CATALOGUE SETUP_PROGS *
*
*      RUN SETUP_PROGS CREATE_DB_FROM_TEMPLATE
*
*      BASIC NXT.BP *
*      CATALOGUE NXT.BP *
*
*      NEXTJOB.MENU  <-- THIS SHOULD START THE NEXTJOB MENU BAR AND AWAY WE GO!

*

* PROCESS STEPS
* 1) TAKES DYNAMIC FILES DEFINED IN JSON TEMPLATE AND CREATES FILES AND DIRECTORIES FOR NEXTJOB APPLICATION
* 2)
*
*
*
$INCLUDE GUIBP ATGUIEQUATES
$INCLUDE SYSCOM KEYS.H
*
EQU DICT.CMP.SZ TO 10  ;* MAX SIZE OF DIRECTORY
*
* THIS IS THE PATH TO WHERE WE SAVE DATA FROM THE BUILD PROCESS AND THE FILE NAME WE WILL USE

SOURCE_DATA_PATH ="C:\QMACCOUNTS\":@WHO
TEMPLATE_DATA_PATH = SOURCE_DATA_PATH:@DS:"SETUP_DATA"
*
DB_TEMPLATE_FILE = "FILES.JSON"
VAL_TEMPLATE_FILE = "VALIDATE.JSON"
*
* THIS IS WHERE WE WILL BUILD THE DATABASE
UPGRADE_DATA_PATH ="C:\QMACCOUNTS\":@WHO

*
MSGS = ''    ;* LIST OF ERRORS FOUND DURING UPGRADE
DISPLAY.ALL = @TRUE  ;* DISPLAY RESULTS FOR ALL TEST (@TRUE) OR ONLY ERRORS (@FALSE)
*
CRT @(-1):

CRT
CRT '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++'
CRT ' PROGRAM CREATES A QM DATA BASE FROM PREVIOUSLY CREATED INSTALL TEMPLATE FILE '
CRT ''
CRT ' IN ACCOUNT: ': @WHO
CRT ''
CRT '  - ENTER OK TO CONTINUE                                            '
CRT '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++'
CRT
*
CRT 'OK':
INPUT OK
IF OK # 'OK' THEN STOP 'Process Aborted'
*
* LOOK FOR THE NXT.INCLUDE FILE
*
NXT.INCLUDE.PATH = UPGRADE_DATA_PATH:@DS:'NXT.INCLUDES'
IF NOT(OSPATH(NXT.INCLUDE.PATH,OS$EXISTS)) THEN
   CRT 'WARNING, NXT.INCLUDES NOT FOUND IN :':UPGRADE_DATA_PATH:' - GENERATE WILL FAIL!'
   CRT 'ENTER OK TO CONTINUE, "X" TO ABOURT'
   INPUT OK:
   IF OK = "X" THEN STOP
END

*
*
OPENPATH TEMPLATE_DATA_PATH TO TEMPLATE.DATA.FILE.VAR THEN
   *   MARK.MAPPING UPGRADE.DATA.FILE.VAR, OFF
   READ JSON.REC FROM TEMPLATE.DATA.FILE.VAR, DB_TEMPLATE_FILE THEN
      CONVERT @FM TO '' IN JSON.REC
      *      CRT JSON.REC
   END ELSE
      CRT 'CANNOT READ ':DB_TEMPLATE_FILE:
      CALL !ERRTEXT(TEXT, STATUS())
      CRT 'ERROR ' : STATUS() : ' ' TEXT
      STOP
   END
END ELSE
   CRT 'CANNOT OPEN ':TEMPLATE_DATA_PATH
   CALL !ERRTEXT(TEXT, STATUS())
   CRT 'ERROR ' : STATUS() : ' ' TEXT
   STOP
END
*
* 1) TAKES DYNAMIC FILES DEFINED IN JSON TEMPLATE AND CREATES FILES AND DIRECTORIES FOR NEXTJOB APPLICATION
*
MYDC = JPARSE(JSON.REC)
MYSTATUS  =  STATUS()
IF MYSTATUS # 0 THEN
   CALL !ERRTEXT(TEXT, MYSTATUS)
   CRT 'ERROR ' : MYSTATUS : ' ' TEXT
   STOP
END

*
ENU_FILES = ENUMERATE(MYDC{'Files'})
*
NBR_OF_FILES = DCOUNT(ENU_FILES,@FM)
CRT NBR_OF_FILES : ' FILES TO PROCESS'
*
FILES.PROCESSED.LIST = ''
*
FOR I = 1 TO NBR_OF_FILES

   FILEDC = MYDC{'Files',ENU_FILES<I>}

   FILE.NAME = FILEDC{'Filename'}

   IF FILE.NAME = '' THEN

      MSGS<-1> = 'Missing File Name at Data Collection ENUM ':I

   END ELSE

      FILES.PROCESSED.LIST<-1> =  FILE.NAME

      FULL.PATH.FILE.NAME = UPGRADE_DATA_PATH:@DS:FILE.NAME

      MSGS<-1> = 'FILE NAME: ':FULL.PATH.FILE.NAME
      *
      * IF FILE DOES NOT EXIST CREATE IT,
      *  THIS COULD HAPPEN IF THIS IS AN UPGRADE


      OPEN  FILE.NAME TO FILE.NAME.VAR THEN
         NULL
      END ELSE
         *
         * USING THE FOLLOWING FORM CREATES BOTH DATA AND DICT PORTION ALONG WITH VOC ENTRY
         *
         EXECUTE "CREATE-FILE ": FILE.NAME : " DYNAMIC "
         MSGS<-1> = 'FILE NAME: ':FULL.PATH.FILE.NAME:' - CREATED'
      END


      ARRY_DICT_ITEMS =  ENUMERATE(FILEDC{'Dictionary'})

      *   CRT ARRY_DICT_ITEMS

      DICTDC = FILEDC{'Dictionary'}

      *
      * NOW CREATE THE DICTIONARY ITEMS
      *
      OPEN "DICT", FILE.NAME TO FILE.DICT.VAR THEN
         *
         * FOR EACH DIRECTORY ENTRY IN DATA COLLECTION, ATTEMPT TO READ DICT ITEM
         *  IF NOT FOUND CREATE
         *  SHOULD WE VALIDATE ONES AREADY ON FILE?? FOUND DURING UPGRADE?

         INCLUDE.FOUND = @FALSE    ;* IF WE FIND A $INCLUDE RECORD PERFORM A GENERATE COMMAND AT COMPLETION OF THE DIRECTORY CREATION (USED BY APPLICATION PROGS, CONSULT QM DOCS)
         CRT 'Creating Dictionaries for ':FILE.NAME
         FOR X = 1 TO DCOUNT(ARRY_DICT_ITEMS,@FM)
            DICT.NAME =  DICTDC{ARRY_DICT_ITEMS<X>,'Dictname'}

            READ DICT.REC FROM FILE.DICT.VAR, DICT.NAME THEN
               MSGS<-1> = 'FILE NAME: ':DICT.NAME:' - ALREADY ON FILE'

            END ELSE
               DICT.REC = ''
               FOR DI = 1 TO DICT.CMP.SZ

                  FLD = DICTDC{ARRY_DICT_ITEMS<X>,DI}
                  IF FLD # '' THEN
                     DICT.REC<DI> = FLD
                  END
               NEXT DI


               *CRT  '
               *CRT  '   Fld 1 ': DICTDC{ARRY_DICT_ITEMS<X>,'1'}
               *CRT  '   Fld 2 ': DICTDC{ARRY_DICT_ITEMS<X>,'2'}
               *CRT  '   Fld 3 ': DICTDC{ARRY_DICT_ITEMS<X>,'3'}
               *CRT  '   Fld 4 ': DICTDC{ARRY_DICT_ITEMS<X>,'4'}
               *CRT  '   Fld 5 ': DICTDC{ARRY_DICT_ITEMS<X>,'5'}
               *CRT  '   Fld 6 ': DICTDC{ARRY_DICT_ITEMS<X>,'6'}

               IF DICT.REC # '' THEN
                  MSGS<-1> = 'WRITING DIRECTORY FOR: ':FILE.NAME:' : ':DICT.NAME
                  WRITE DICT.REC ON FILE.DICT.VAR, DICT.NAME
                  IF DICT.NAME = '$INCLUDE' THEN
                     INCLUDE.FOUND = @TRUE
                  END
               END

            END

         NEXT X

         *
         * GENERATE THE INDEX FILE FOR THIS DICTIONARY
         *
         IF INCLUDE.FOUND THEN
            CRT 'Generate Include Records for ':FILE.NAME
            MSGS<-1> = 'PERFORM GENERATE FOR: ':FILE.NAME
            EXECUTE "GENERATE ": FILE.NAME
         END



      END ELSE
         CRT 'ERROR CANNOT OPEN DICTIONAY; ' :FILE.NAME:".DIC, THIS SHOULD NOT HAPPEN!"
         CRT "BUILD ABORT"
         STOP
      END




   END

NEXT I
*
* FINALLY RECOMPILE THE DICTIONARIES
*
FOR I = 1 TO DCOUNT(FILES.PROCESSED.LIST,@FM)
   EXECUTE "COMPILE.DICT ":FILES.PROCESSED.LIST<I>
NEXT I
*
*FOR I = 1 TO DCOUNT(MSGS,@FM)
*CRT MSGS
*NEXT I
*
WRITE MSGS TO TEMPLATE.DATA.FILE.VAR, 'CREATE_DB_TEMPLATE_MSGS'
CRT 'PROGRAM MESSAGES WRITEN TO ':TEMPLATE_DATA_PATH

*
END