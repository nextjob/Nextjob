*
* PROGRAM CREATES DATA BASE INSTALL TEMPLATE FILE
* PROCESS STEPS
* 1) TAKES DYNAMIC FILES DEFINED IN FILES_LIST AND CREATES JSON FILE DEFINING FILES AND DICTIONARY ITEMS
* 2)
*
*
*
$INCLUDE GUIBP ATGUIEQUATES
$INCLUDE SYSCOM KEYS.H
$INCLUDE NXT.INCLUDES NXT.EQUATES
$INCLUDE NXT.INCLUDES SYSTEM_FILE.EQU
*
*
EQU DICT.CMP.SZ TO 10
*
* HARD CODED LOCATION FOR BUILD PROCESS (NEED TO CHANGE TO USER INPUT / SELECTED FIELD?)
*
SOURCE_DATA_PATH ="C:\QMACCOUNTS\NEXTJOB\"
*
* THIS IS THE PATH TO WHERE WE SAVE DATA FROM THE BUILD PROCESS AND THE FILE NAME WE WILL USE
TEMPLATE_DATA_PATH = SOURCE_DATA_PATH:"SETUP_DATA"
DB_TEMPLATE_FILE = "FILES.JSON"
VAL_TEMPLATE_FILE = "VALIDATE.JSON"
*
*
*
CRT @(-1):

CRT
CRT '++++++++++++++++++++++++++++++++++++++++++++++++++++'
CRT ' PROGRAM CREATES DATA BASE INSTALL TEMPLATE FILES   '
CRT ' WILL BE SAVED IN DIRECTORY ':DB_TEMPLATE_FILE
CRT '++++++++++++++++++++++++++++++++++++++++++++++++++++'
CRT
*
CRT 'Enter OK To Continue':
INPUT OK
IF OK # 'OK' THEN STOP 'Process Aborted'
*
ERRORS = ''    ;* LIST OF ERRORS FOUND DURING UPGRADE
DISPLAY.ALL = @FALSE  ;* DISPLAY RESULTS FOR ALL TEST (@TRUE) OR ONLY ERRORS (@FALSE)
*
* FILES LIST
* CREATE AN ENTRY IN DATA BASE INSTALL TEMPLATE FILE
*
FILES_LIST = ''
*
FILES_LIST<-1> = "SYS_LOG"
FILES_LIST<-1> = "ORDER_PARENT"
FILES_LIST<-1> = "ORDER_CHILD"
FILES_LIST<-1> = "CUSTOMERS"
FILES_LIST<-1> = "SHIP_TO"
FILES_LIST<-1> = "PARTS"
FILES_LIST<-1> = "RECEIPTS"
FILES_LIST<-1> = "LOT_TRACE"
FILES_LIST<-1> = "SALES"
FILES_LIST<-1> = "AR"
FILES_LIST<-1> = "PROCESS_STEPS"
FILES_LIST<-1> = "PROCESS_GROUPS"
FILES_LIST<-1> = "CERTS"
FILES_LIST<-1> = "AR_CHECKS"
FILES_LIST<-1> = "VALIDATION_FILE"
FILES_LIST<-1> = "SYSTEM_FILE"
FILES_LIST<-1> = "PARTS_QTY"
FILES_LIST<-1> = "VENDORS"
FILES_LIST<-1> = "VSHIP_TO"
FILES_LIST<-1> = "WC"
FILES_LIST<-1> = "RT"
FILES_LIST<-1> = "WO"
FILES_LIST<-1> = "WR"
FILES_LIST<-1> = "OPERATIONS"
FILES_LIST<-1> = "RTREV"
FILES_LIST<-1> = "EMPLOYEES"
FILES_LIST<-1> = "LABOR_TICKETS"
FILES_LIST<-1> = "LABOR_TRANS"
FILES_LIST<-1> = "PO_PARENT"
FILES_LIST<-1> = "PO_CHILD"
FILES_LIST<-1> = "PARTS_BOM"
FILES_LIST<-1> = "AP_CHECKS"
FILES_LIST<-1> = "AP_INVOICE"
FILES_LIST<-1> = "GLT"
FILES_LIST<-1> = "QA_MASTER"
FILES_LIST<-1> = "QAD_PARENT"
FILES_LIST<-1> = "QAD_CHILD"
FILES_LIST<-1> = "WC_LOAD"
*
FILE_CT = DCOUNT(FILES_LIST,@AM)
*
VALIDATION_FILE_ITEMS = ''
VALIDATION_FILE_ITEMS<-1> = 'BANKS'
VALIDATION_FILE_ITEMS<-1> = 'BREAKS'
VALIDATION_FILE_ITEMS<-1> = 'CERT.DESC'
VALIDATION_FILE_ITEMS<-1> = 'CM.STATUS'
VALIDATION_FILE_ITEMS<-1> = 'COUNTRY'
VALIDATION_FILE_ITEMS<-1> = 'DEPARTMENTS'
VALIDATION_FILE_ITEMS<-1> = 'EXTRA.CHARGES'
VALIDATION_FILE_ITEMS<-1> = 'GL.TRANS.CODES'
VALIDATION_FILE_ITEMS<-1> = 'LOT.CHARGES'
VALIDATION_FILE_ITEMS<-1> = 'MATERIAL'
VALIDATION_FILE_ITEMS<-1> = 'ORDER.CLASS'
VALIDATION_FILE_ITEMS<-1> = 'ORDER.TYPE'
VALIDATION_FILE_ITEMS<-1> = 'QA.METHODS'
VALIDATION_FILE_ITEMS<-1> = 'SALES.CODES'
VALIDATION_FILE_ITEMS<-1> = 'SALES.PERSONS'
VALIDATION_FILE_ITEMS<-1> = 'SALES.TAX'
VALIDATION_FILE_ITEMS<-1> = 'SEQ.STATUS'
VALIDATION_FILE_ITEMS<-1> = 'SHIFTS'
VALIDATION_FILE_ITEMS<-1> = 'SHIP.VIA'
VALIDATION_FILE_ITEMS<-1> = 'SIGNOFF'
VALIDATION_FILE_ITEMS<-1> = 'STATES'
VALIDATION_FILE_ITEMS<-1> = 'TERMS'
VALIDATION_FILE_ITEMS<-1> = 'VN.STATUS'
*
VALIDATION_FILE_ITEMS_CT = DCOUNT(VALIDATION_FILE_ITEMS,@AM)
*
*  RECORDS FOUND IN SYSTEM_FILE
*
SYSTEM_FILE_ITEMS = ''
SYSTEM_FILE_ITEMS<-1> = "CFLD*ORDER_PARENT"  ;* CUSTOMER DEFINED FIELDS ON ORDER_PARENT ENTRY SCREEN
SYSTEM_FILE_ITEMS<-1> = "CFLD*ORDER_CHILD"
SYSTEM_FILE_ITEMS<-1> = "CFLD*PARTS"
SYSTEM_FILE_ITEMS<-1> = "CFLD*WC"
SYSTEM_FILE_ITEMS<-1> = "CFLD*WO"
SYSTEM_FILE_ITEMS<-1> = "CFLD*WRT"
SYSTEM_FILE_ITEMS<-1> = "CHART_OF_ACCOUNTS"
SYSTEM_FILE_ITEMS<-1> = "DEFAULTS"  ;* <-- DO WE VALIDATE IF SO HOW, SIMPLE FIELD COUNT??
SYSTEM_FILE_ITEMS<-1> = "HOLIDAYS"
SYSTEM_FILE_ITEMS<-1> = "NETWORK_PATH"
SYSTEM_FILE_ITEMS<-1> = "HOLIDAYS"
SYSTEM_FILE_ITEMS<-1> = "UTILITY_APPS_PATH"
SYSTEM_FILE_ITEMS<-1> = "PROCESS_STEP_CHECKS"
SYSTEM_FILE_ITEMS_CT = DCOUNT(SYSTEM_FILE_ITEMS,@AM)
*

CRT "GENERATE DB TEMPLATE DATA AND SAVE IN ":TEMPLATE_DATA_PATH:' <Y/N>':
INPUT OK
IF OK = 'Y' THEN
   *
   *
   * WE SHOULD NOW HAVE THE DIRECTORY NEED TO SAVE THE DICTIONARY ITEMS TO, OPEN IT
   *
   *
   TEMPLATE_FILE =  TEMPLATE_DATA_PATH:@DS:DB_TEMPLATE_FILE
   OPN.ERROR = ''
   OPENSEQ TEMPLATE_FILE OVERWRITE TO TEMPLATE.FILEVAR THEN
      NULL
   END ELSE
      CREATE TEMPLATE.FILEVAR THEN NULL ELSE OPN.ERROR = TEMPLATE_FILE
   END
   IF OPN.ERROR # '' THEN
      CRT 'ERROR CREATING FILE: ':TEMPLATE_FILE
      CRT 'PROCESS ABORTED'
      STOP
   END
   *
   CRT 'Building Files Template and saving to ':TEMPLATE_FILE
   *
   WRITESEQ '{"Files" : [' TO TEMPLATE.FILEVAR ELSE
      CRT 'ERROR WRITING TO ':TEMPLATE_FILE
      CRT 'PROCESS ABORTED'
      STOP
   END
   *
   * For each file defined in Files_List, create the JSON entry
   *
   CRT FILE_CT :' FILES TO PROCESS'
   FOR I = 1 TO FILE_CT
      *
      WRITESEQ '{"Filename" : "':FILES_LIST<I>:'",' TO TEMPLATE.FILEVAR ELSE NULL

      CRT 'CREATING ENTRIES FOR: ':FILES_LIST<I>

      OPEN "DICT", FILES_LIST<I> TO DICT.FILE.VAR THEN
         *
         * NOW GET THE ACTUAL DICTIONARY ITEMS FOR THE FILE
         *
         SLIST = "SELECT DICT ":FILES_LIST<I>:' TO 2'
         EXECUTE SLIST CAPTURING DMMY.OUT
         *
         BEGIN CASE
               *
            CASE @SELECTED LT 1
               CRT 'No Data Found for ':FILES_LIST<I>
               *
            CASE 1
               *
               *     CREATE THE LIST OF ITEM IDS
               *
               WRITESEQ '"Dictionary": [' TO TEMPLATE.FILEVAR ELSE NULL

               READLIST DICT_IDS FROM 2 THEN
                  LIST.CT = DCOUNT(DICT_IDS,@AM)
                  FOR X = 1 TO LIST.CT
                     READ.ID = DICT_IDS<X>
                     IF DISPLAY.ALL THEN CRT 'Reading Dict: ': FILES_LIST<I> :' ':READ.ID

                     READ DIC.ITEM FROM DICT.FILE.VAR, READ.ID  THEN
                        DICT.SZ = DCOUNT(DIC.ITEM,@AM)
                        DICTDC = COLLECTION()  ;* CREATE MY COLLECTION VAR
                        DICTDC{'Dictname'} = READ.ID
                        *
                        * WE LIMIT THE DATA WE SAVE TO THE NON QM INTERNAL USE DATA (DICT.CMP.SZ)
                        IF DICT.SZ > DICT.CMP.SZ THEN DICT.SZ = DICT.CMP.SZ
                        FOR D =  1 TO DICT.SZ
                           FLD = 'FLD':D
                           DICTDC{D} = DIC.ITEM<D>
                        NEXT D
                        OUTTXT = JBUILD(DICTDC)
                        IF STATUS() # 0 THEN
                           CRT 'ERROR JBUILD FAILED ON  ':FILES_LIST<I>:' ':READ.ID
                           CRT 'PROCESS ABORTED'
                           STOP
                        END

                        WRITESEQ OUTTXT:',' TO TEMPLATE.FILEVAR ELSE NULL

                     END
                  NEXT X
                  WRITESEQ ']' TO TEMPLATE.FILEVAR ELSE NULL
               END

               *
         END CASE
         CLOSE DICT.FILE.VAR
      END ELSE
         ERR.LN =  'Could Not Open Dict for: ':FILES_LIST<I>
         CRT ERR.LN
         ERRORS<-1> = ERR.LN
      END

      IF I = FILE_CT THEN   ;* LAST FILE TO PROCESS?
         WRITESEQ '}' TO TEMPLATE.FILEVAR ELSE NULL
      END ELSE
         WRITESEQ '},' TO TEMPLATE.FILEVAR ELSE NULL
      END
   NEXT I

   WRITESEQ ']}' TO TEMPLATE.FILEVAR ELSE
      CRT 'ERROR WRITING TO ':TEMPLATE_FILE
      CRT 'PROCESS ABORTED'
      STOP
   END

   CLOSESEQ TEMPLATE.FILEVAR

END

BUILD_VALIDATION: *
*
*
* CREATE UPGRADE DATA FOR VALIDATION_FILE
*
CRT 'COPYING VALIDATION FILE ITEMS'
*
FILE.UPGRADE.DATA.DIR.PATH = TEMPLATE_DATA_PATH:@DS:"VALIDATION_FILE_RECORDS"
*
OS.EXECUTE "MKDIR ":FILE.UPGRADE.DATA.DIR.PATH
IF STATUS() # 0 THEN
   CRT 'ERROR CREATING DIRECTORY FOR: ':FILE.UPGRADE.DATA.DIR.PATH
   CRT 'PROCESS ABORTED'
   STOP
END
*
OPENPATH FILE.UPGRADE.DATA.DIR.PATH TO UPGRADE.DATA.FILE.VAR THEN
   OPEN "VALIDATION_FILE" TO VALIDATION_FILE THEN

      SLIST = "SELECT VALIDATION_FILE TO 2"
      EXECUTE SLIST
      *
      READLIST VAL_IDS FROM 2 THEN
         LIST.CT = DCOUNT(VAL_IDS,@AM)
         FOR I = 1 TO LIST.CT
            VAL.ID = VAL_IDS<I>
            CRT 'Copy ':VAL.ID

            UP.VAL.ID = VAL.ID
            CONVERT '*' TO '%' IN UP.VAL.ID  ;* cannot have * in file name!
            READ VAL.REC FROM VALIDATION_FILE, VAL.ID THEN
               WRITE VAL.REC ON UPGRADE.DATA.FILE.VAR, UP.VAL.ID
            END
         NEXT I
      END
   END ELSE
      CRT 'ERROR OPENING VALIDATION_FILE FOR UPGRADE DATA BUILD'
   END
END ELSE
   CRT 'ERROR OPENING: ':FILE.UPGRADE.DATA.DIR.PATH: ' FOR VALIDATION_FILE UPGRADE DATA BUILD'
END


*
* CREATE UPGRADE DATA FOR SYSTEM_FILE
*
CRT 'COPYING SYSTEM FILE ITEMS'

FILE.UPGRADE.DATA.DIR.PATH = TEMPLATE_DATA_PATH:@DS:"SYSTEM_FILE_RECORDS"
*
OS.EXECUTE "MKDIR ":FILE.UPGRADE.DATA.DIR.PATH
IF STATUS() # 0 THEN
   CRT 'ERROR CREATING DIRECTORY FOR: ':FILE.UPGRADE.DATA.DIR.PATH
   CRT 'PROCESS ABORTED'
   STOP
END
*

*
OPENPATH FILE.UPGRADE.DATA.DIR.PATH TO UPGRADE.DATA.FILE.VAR THEN
   OPEN "SYSTEM_FILE" TO SYSTEM_FILE THEN
      FOR I = 1 TO SYSTEM_FILE_ITEMS_CT
         CRT 'Copy ':SYSTEM_FILE_ITEMS<I>
         SYS.ID = SYSTEM_FILE_ITEMS<I>
         UP.SYS.ID = SYS.ID
         CONVERT '*' TO '%' IN UP.SYS.ID  ;* cannot have * in file name!
         READ SYS.REC FROM SYSTEM_FILE, SYS.ID THEN
            WRITE SYS.REC ON UPGRADE.DATA.FILE.VAR, UP.SYS.ID
         END
      NEXT I
   END ELSE
      CRT 'ERROR OPENING SYSTEM_FILE FOR UPGRADE DATA BUILD'
   END
END ELSE
   CRT 'ERROR OPENING: ':FILE.UPGRADE.DATA.DIR.PATH: ' FOR SYSTEM_FILE UPGRADE DATA BUILD'
END

*
* WRAP IT UP
*
ERROR.CT = DCOUNT(ERRORS,@AM)
IF ERROR.CT > 0 THEN
ERR.00: *
   CRT 'ERRORS FOUND DURING UPGRADE, DISPLAY THEM <Y/N>':
   INPUT DSP.ERRORS
   BEGIN CASE
      CASE DSP.ERRORS = 'Y'
         FOR I = 1 TO ERROR.CT
            CRT ERRORS<I>
         NEXT I
      CASE DSP.ERRORS = 'N'
         NULL
      CASE 1
         CRT 'INVALID RESPONSE, RETRY'
         GOTO ERR.00
   END CASE
   *
END

CRT 'Build Process Complete'

END
